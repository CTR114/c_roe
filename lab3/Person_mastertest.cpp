// Person_mastertest.cpp
// Tests for Person class
// Theresa Wilson & Barb Wahl, 2-21-17

// NOTE:  Execution of student code will still be halted by fatal errors such
// as segmentation faults and infinite loops.  Make use of the methods
// `segFault` and `infiniteLoop` in these situations.

// NOTE:  As much as possible, use only *basic* functionality in implementing
// testing code.

// ========================= Testing Boilerplate =========================
#include <cassert>
#include <sstream>
#include <iostream>
#include <string>
#include "Person.h"

using namespace std;

const string err = "";
int tests_passed = 0;
int tests_failed = 0;
int segmentation_faults = 0;
int infinite_loops = 0;

// print method
// prints the given string plus endl
void print(string str) {
   cout << str << endl;
}

// segFault method
// When student code creates a segmentation fault, comment out the corresponding
// test call in main and *insert* a call to segFault.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// segmentation_faults counter.
void segFault(string desc) {
   print("### TEST FAILED ###: " + desc + "; segmentation fault");
   tests_failed++;
   segmentation_faults++;
}

// infiniteLoop method
// When student code creates an infinite loop, comment out the corresponding
// test call in main and *insert* a call to infiniteLoop.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// infinite_loops counter.
void infiniteLoop(string desc) {
   print("### TEST FAILED ###: " + desc + "; infinite loop");
   tests_failed++;
   infinite_loops++;
}

// itFailedToThrowCorrectException method
// input: string desc, describes the test which was run
void itFailedToThrowCorrectException(string desc) {
   print("### TEST FAILED ###: " + desc + "; threw non-string exeception");
   tests_failed++;
}

// itFailed method
// ## always call this method when a test fails, except when the code under
// test threw the *wrong* exception -- see `itFailedToThrowCorrectException` ##
// prints message for failed test
// increments the count of failed tests
void itFailed(string str) {
   print("### TEST FAILED ###: " + str);
   tests_failed++;
}

// itPassed method
// ## always call this method when a test passes ##
// prints message for passed test
// increments the count of passed tests
void itPassed(string str) {
   print("TEST PASSED: " + str);
   tests_passed++;
}

// stripSpaceAndMakeLowerCase function
// input:  string s
// output: string
//
// makes a copy of string s, strips ' ' and '\n' from
// the copy, and changes all remaining chars to lower case
//
// returns this altered copy of the string
//
// leaves the original string s unchanged
string stripSpacesAndMakeLowerCase(string s)
{
   string str = s;
   for (unsigned int i = 0; i < str.length(); i++)
   {
      if (str[i]==' ' or str[i]=='\n') {
         str.erase(i,1);
         i--;
      }
      else { str[i] = tolower(str[i]); }
   }
   return str;
}

// laxString method
// use for comparing strings generated by stream output (<<)
// ignores whitespace, including newlines
// return:  true iff s1 and s2 are equivalent after ignoring whitespace
bool laxString(string s1,string s2)
{
   string x = stripSpacesAndMakeLowerCase(s1);
   string y = stripSpacesAndMakeLowerCase(s2);
   return x == y;
}

// ========================= Tests =========================

//    Person instance variables:
//      string first
//      string last
//      int age

//    Person member functions:
//      Person (constructor) - may be called with 0, 1, 2, or 3 args
//      getFirstName
//      getLastName
//      getAge
//      getFullName
//      setFirstName
//      setLastName
//      setAge
//      agePerson

// construct a default Person
// use getFirstName(), getLastName(), getAge()
void test_constructor_0() {
   Person p1;
   string desc = "construct a default Person";
   try {
      if (p1.getFirstName() != "J") { throw err; }
      if (p1.getLastName() != "Doe") { throw err; }
      if (p1.getAge() != 0) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// construct a 1-arg Person
// use getFirstName(), getLastName(), getAge()
void test_constructor_1() {
   Person p1("Ziggy");
   string desc = "construct a Person given first name only";
   try {
      if (p1.getFirstName() != "Ziggy") { throw err; }
      if (p1.getLastName() != "Doe") { throw err; }
      if (p1.getAge() != 0) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// construct a 2-arg Person
// use getFirstName(), getLastName(), getAge()
void test_constructor_2() {
   Person p1("Ziggy", "Wilson");
   string desc = "construct a Person given first name and last name";
   try {
      if (p1.getFirstName() != "Ziggy") { throw err; }
      if (p1.getLastName() != "Wilson") { throw err; }
      if (p1.getAge() != 0) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// construct a 3-arg Person
// use getFirstName(), getLastName(), getAge()
void test_constructor_3() {
   Person p1("Ziggy", "Wilson", 7);
   string desc = "construct a Person given first name, last name, and age";
   try {
      if (p1.getFirstName() != "Ziggy") { throw err; }
      if (p1.getLastName() != "Wilson") { throw err; }
      if (p1.getAge() != 7) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// get the full name of a Person
void test_additional_getters_1() {
   Person p1("Ziggy", "Wilson", 7);
   string desc = "get the full name of a Person";
   try {
      if (p1.getFullName() != "Ziggy Wilson") { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// set a Person's first name
void test_setters_1() {
   Person p1("Ziggy", "Wilson", 7);
   string desc = "setting the first name of a Person";
   p1.setFirstName("Spike");
   try {
      if (p1.getFirstName() != "Spike") { throw err; }
      if (p1.getLastName() != "Wilson") { throw err; }
      if (p1.getAge() != 7) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// set a Person's last name
void test_setters_2() {
   Person p1("Ziggy", "Wilson", 7);
   string desc = "setting the last name of a Person";
   p1.setLastName("Morrison");
   try {
      if (p1.getFirstName() != "Ziggy") { throw err; }
      if (p1.getLastName() != "Morrison") { throw err; }
      if (p1.getAge() != 7) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// set a Person's age
void test_setters_3() {
   Person p1("Ziggy", "Wilson", 7);
   string desc = "setting the age of a Person";
   p1.setAge(10);
   try {
      if (p1.getFirstName() != "Ziggy") { throw err; }
      if (p1.getLastName() != "Wilson") { throw err; }
      if (p1.getAge() != 10) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// age a Person
void test_age_person() {
   Person p1("Ziggy", "Wilson", 7);
   string desc = "aging a Person one year";
   p1.agePerson();
   try {
      if (p1.getFirstName() != "Ziggy") { throw err; }
      if (p1.getLastName() != "Wilson") { throw err; }
      if (p1.getAge() != 8) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// == operator and != operator
void test_equiv_inequiv_1() {
   Person p1("Ziggy", "Wilson", 7);
   Person p2("Ziggy", "Wilson", 7);
   string desc = "equiv/inequiv: comparing two equivalent Persons";
   try {
      if (!(p1 == p2)) { throw err; }
      if (!(p2 == p1)) { throw err; }
      if (p1 != p2) { throw err; }
      if (p2 != p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// == operator and != operator
void test_equiv_inequiv_2() {
   Person p1("Ziggy", "Wilson", 7);
   Person p2("Ziggy", "Wilson", 8);
   string desc = "equiv/inequiv: comparing two Person differing only in age";
   try {
      if (!(p1 != p2)) { throw err; }
      if (!(p2 != p1)) { throw err; }
      if (p1 == p2) { throw err; }
      if (p2 == p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// == operator and != operator
void test_equiv_inequiv_3() {
   Person p1("Ziggy", "Wilson", 7);
   Person p2("Ziggy", "Morrison", 7);
   string desc = "equiv/inequiv: comparing two Person differing only in last name";
   try {
      if (!(p1 != p2)) { throw err; }
      if (!(p2 != p1)) { throw err; }
      if (p1 == p2) { throw err; }
      if (p2 == p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// == operator and != operator
void test_equiv_inequiv_4() {
   Person p1("Ziggy", "Wilson", 7);
   Person p2("Spike", "Wilson", 7);
   string desc = "equiv/inequiv: comparing two Person differing only in first name";
   try {
      if (!(p1 != p2)) { throw err; }
      if (!(p2 != p1)) { throw err; }
      if (p1 == p2) { throw err; }
      if (p2 == p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// < operator 
void test_less_than_1() {
   Person p1("Ziggy", "Wilson", 7);
   Person p2("Ziggy", "Wilson", 7);
   string desc = "less-than operator: p1 == p2";
   try {
      if (p1 < p2) { throw err; }
      if (p2 < p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// < operator 
void test_less_than_2() {
   Person p1("Ziggy", "Wilson", 6);
   Person p2("Ziggy", "Wilson", 7);
   string desc = "less-than operator: p1 < p2 based only on age";
   try {
      if (!(p1 < p2)) { throw err; }
      if (p2 < p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// < operator 
void test_less_than_3() {
   Person p1("Spike", "Wilson", 7);
   Person p2("Ziggy", "Wilson", 7);
   string desc = "less-than operator: p1 < p2 based only on first name";
   try {
      if (!(p1 < p2)) { throw err; }
      if (p2 < p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// < operator 
void test_less_than_4() {
   Person p1("Ziggy", "Morrison", 7);
   Person p2("Ziggy", "Wilson", 7);
   string desc = "less-than operator: p1 < p2 based only on last name";
   try {
      if (!(p1 < p2)) { throw err; }
      if (p2 < p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// < operator 
void test_less_than_5() {
   Person p1("Ziggy", "Morrison", 7);
   Person p2("Spike", "Wilson", 7);
   string desc = "less-than operator: p1 < p2 by last name, but with p2.first < p1.first";
   try {
      if (!(p1 < p2)) { throw err; }
      if (p2 < p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// < operator 
void test_less_than_6() {
   Person p1("Ziggy", "Morrison", 7);
   Person p2("Ziggy", "Wilson", 6);
   string desc = "less-than operator: p1 < p2, by last name, but with p2.age < p1.age";
   try {
      if (!(p1 < p2)) { throw err; }
      if (p2 < p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// < operator 
void test_less_than_7() {
   Person p1("Spike", "Wilson", 7);
   Person p2("Ziggy", "Wilson", 6);
   string desc = "less-than operator: p1 < p2, by first name, but with p2.age < p1.age";
   try {
      if (!(p1 < p2)) { throw err; }
      if (p2 < p1) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// + operator 
void test_addition_1() {
   string desc = "person addition +";
   Person p1("Kermit", "Frog", 34);
   Person p2("Miss", "Piggy", 35);
   Person baby1 = p1 + p2;
   try {
      if (baby1.getFirstName() != "Baby") { throw err; }
      if (baby1.getAge() != 0) { throw err; }
      if (baby1.getLastName() != "Frog-Piggy") { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// test stream I/O
void test_stream_input()
{
   string desc = "stream input >>";
   stringstream in;
   string correct;
   Person p("Kermit", "Frog", 36);

   in << "Person: Miss Piggy, age 35\n";
   in >> p;

   try {
      if (p.getFirstName() != "Miss") { throw err; }
      if (p.getLastName() != "Piggy") { throw err; }
      if (p.getAge() != 35) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}


// test stream I/O
void test_stream_output()
{
   string desc = "stream output <<";
   stringstream out;
   Person p("Ziggy", "Wilson", 7);
   out << p;

   string correct = "Person: Ziggy Wilson, age 7";
   string actual = out.str();

   try {
      if ( !(actual == correct) && !((actual + "\n") == correct)
           && !(actual == (correct + "\n"))) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}


int main() {
   print("\nRunning Mastertest for Lab 3 Person class . . .");

   test_constructor_0();
   test_constructor_1();
   test_constructor_2();
   test_constructor_3();
   test_additional_getters_1();
   test_setters_1();
   test_setters_2();
   test_setters_3();
   test_age_person();
   test_equiv_inequiv_1();
   test_equiv_inequiv_2();
   test_equiv_inequiv_3();
   test_equiv_inequiv_4();
   test_less_than_1();
   test_less_than_2();
   test_less_than_3();
   test_less_than_4();
   test_less_than_5();
   test_less_than_6();
   test_less_than_7();
   test_addition_1();
   test_stream_input();
   test_stream_output();

   // ======================== SUMMARY INFORMATION ====================== //
   int num_tests = tests_passed + tests_failed;
   double passed = (double) tests_passed;
   double total = (double) num_tests;
   cout << "\nNumber of segmentation faults encountered during testing = "
        << segmentation_faults << endl;
   cout << "Number of infinite loops encountered during testing = "
        << infinite_loops << endl;
   cout << "Number of tests passed = " << tests_passed << " out of "
        << num_tests << endl;
   cout << "Number of tests failed = " << tests_failed << " out of "
        << num_tests << endl;
   cout << "Percent of tests passed = " << (100 * passed / total)
        << "%" << endl << endl;

   return 0;
}
