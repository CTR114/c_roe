// Pixel_mastertest.cpp
// Tests for Pixel class
// Theresa Wilson, 2-20-16

// NOTE:  Execution of student code will still be halted by fatal errors such
// as segmentation faults and infinite loops.  Make use of the methods
// `segFault` and `infiniteLoop` in these situations.

// NOTE:  As much as possible, use only *basic* functionality in implementing
// testing code.

// NOTE:  Since the testing code is implemented using the student's
// implementations for basic functionality (part 1), any problems in basic functionality
// must be "patched" by the instructor (after recording the relevant info)
// before re-running the tests.  Save the altered code as, for example,
// Sequence_patched.cpp, then re-compile to evaluate non-basic functionality.

// ========================= Testing Boilerplate =========================
#include <cassert>
#include <sstream>
#include <iostream>
#include <string>
#include "Pixel.h"

using namespace std;
using namespace imagelab;

extern string EXC_OUT_OF_BOUNDS;
extern string EXC_LIST_NOT_ORDERED;

const string err = "";
int tests_passed = 0;
int tests_failed = 0;
int segmentation_faults = 0;
int infinite_loops = 0;

// print method
// prints the given string plus endl
void print(string str) {
   cout << str << endl;
}

// segFault method
// When student code creates a segmentation fault, comment out the corresponding
// test call in main and *insert* a call to segFault.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// segmentation_faults counter.
void segFault(string desc) {
   print("### TEST FAILED ###: " + desc + "; segmentation fault");
   tests_failed++;
   segmentation_faults++;
}

// infiniteLoop method
// When student code creates an infinite loop, comment out the corresponding
// test call in main and *insert* a call to infiniteLoop.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// infinite_loops counter.
void infiniteLoop(string desc) {
   print("### TEST FAILED ###: " + desc + "; infinite loop");
   tests_failed++;
   infinite_loops++;
}

// itFailedToThrowCorrectException method
// input: string desc, describes the test which was run
void itFailedToThrowCorrectException(string desc) {
   print("### TEST FAILED ###: " + desc + "; threw non-string exeception");
   tests_failed++;
}

// itFailed method
// ## always call this method when a test fails, except when the code under
// test threw the *wrong* exception -- see `itFailedToThrowCorrectException` ##
// prints message for failed test
// increments the count of failed tests
void itFailed(string str) {
   print("### TEST FAILED ###: " + str);
   tests_failed++;
}

// itPassed method
// ## always call this method when a test passes ##
// prints message for passed test
// increments the count of passed tests
void itPassed(string str) {
   print("TEST PASSED: " + str);
   tests_passed++;
}

// stripSpaceAndMakeLowerCase function
// input:  string s
// output: string
//
// makes a copy of string s, strips ' ' and '\n' from
// the copy, and changes all remaining chars to lower case
//
// returns this altered copy of the string
//
// leaves the original string s unchanged
string stripSpacesAndMakeLowerCase(string s)
{
   string str = s;
   for (unsigned int i = 0; i < str.length(); i++)
   {
      if (str[i]==' ' or str[i]=='\n') {
         str.erase(i,1);
         i--;
      }
      else { str[i] = tolower(str[i]); }
   }
   return str;
}

// laxString method
// use for comparing strings generated by stream output (<<)
// ignores whitespace, including newlines
// return:  true iff s1 and s2 are equivalent after ignoring whitespace
bool laxString(string s1,string s2)
{
   string x = stripSpacesAndMakeLowerCase(s1);
   string y = stripSpacesAndMakeLowerCase(s2);
   return x == y;
}

// ========================= Tests =========================

// Test Pixel basic functionality
//    Pixel (constructor)
//    getRed
//    getGreen
//    getBlue
//    set
//    setRed
//    setGreen
//    setBlue

// construct a default pixel
// use getRed(), getGreen(), and getBlue()
void test_constructor_1() {
   Pixel pix1;
   string desc = "construct a default pixel";
   try {
      if (pix1.getRed() != 0) { throw err; }
      if (pix1.getGreen() != 0) { throw err; }
      if (pix1.getBlue() != 0) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// construct a pixel with default green and blue values
// use getRed(), getGreen(), and getBlue()
void test_constructor_2() {
   Pixel pix1(255);
   string desc = "construct a pixel with default green and blue values";
   try {
      if (pix1.getRed() != 255) { throw err; }
      if (pix1.getGreen() != 0) { throw err; }
      if (pix1.getBlue() != 0) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// construct a pixel with default blue value
// use getRed(), getGreen(), and getBlue()
void test_constructor_3() {
   Pixel pix1(255,255);
   string desc = "construct a pixel with default blue value";
   try {
      if (pix1.getRed() != 255) { throw err; }
      if (pix1.getGreen() != 255) { throw err; }
      if (pix1.getBlue() != 0) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// construct a white pixel
// use getRed(), getGreen(), and getBlue()
void test_constructor_4() {
   Pixel pix1(255,255,255);
   string desc = "construct a white pixel";
   try {
      if (pix1.getRed() != 255) { throw err; }
      if (pix1.getGreen() != 255) { throw err; }
      if (pix1.getBlue() != 255) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// use set to change the colors of a pixel
// use set(), getRed(), getGreen(), and getBlue()
void test_setters_1() {
   Pixel pix1;
   pix1.set(255,255,255);
   string desc = "use set to change the colors of a pixel";
   try {
      if (pix1.getRed() != 255) { throw err; }
      if (pix1.getGreen() != 255) { throw err; }
      if (pix1.getBlue() != 255) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// use setRed to change the red color of a pixel
// use setRed(), getRed(), getGreen(), and getBlue()
void test_setters_2() {
   Pixel pix1;
   pix1.setRed(255);
   string desc = "use setRed to change the red value of a pixel";
   try {
      if (pix1.getRed() != 255) { throw err; }
      if (pix1.getGreen() != 0) { throw err; }
      if (pix1.getBlue() != 0) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// use setGreen to change the green color of a pixel
// use setGreen(), getRed(), getGreen(), and getBlue()
void test_setters_3() {
   Pixel pix1;
   pix1.setGreen(255);
   string desc = "use setGreen to change the green value of a pixel";
   try {
      if (pix1.getRed() != 0) { throw err; }
      if (pix1.getGreen() != 255) { throw err; }
      if (pix1.getBlue() != 0) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// use setBlue to change the blue color of a pixel
// use setBlue(), getRed(), getGreen(), and getBlue()
void test_setters_4() {
   Pixel pix1;
   pix1.setBlue(255);
   string desc = "use setBlue to change the blue value of a pixel";
   try {
      if (pix1.getRed() != 0) { throw err; }
      if (pix1.getGreen() != 0) { throw err; }
      if (pix1.getBlue() != 255) { throw err; }
      itPassed(desc);
   }
   catch(string s){ itFailed(desc + " " + s); }
}

// Test Pixel operator overloading
//    equality (==)
//    inequality (!=)
//    stream output (<<)
//    stream input (>>)

// == operator and != operator
void test_eq_noteq_1()
{
   string desc = "pix1 == pix1";
   Pixel pix1;
   try {
      if (!(pix1 == pix1)) { throw err; }
      if (pix1 != pix1) { throw err; }
      itPassed(desc);
   }
   catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_2()
{
   string desc = "pix1 == pix2";
   Pixel pix1(75,85,95);
   Pixel pix2(75,85,95);
   try {
      if (!(pix1 == pix2)) { throw err; }
      if (pix1 != pix2) { throw err; }
      itPassed(desc);
   }
   catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_3()
{
   string desc = "pix1 != pix2, red color value different";
   Pixel pix1(75,85,95);
   Pixel pix2(100,85,95);
   try {
      if (pix1 == pix2) { throw err; }
      if (!(pix1 != pix2)) { throw err; }
      itPassed(desc);
   }
   catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_4()
{
   string desc = "pix1 != pix2, green color value different";
   Pixel pix1(75,85,95);
   Pixel pix2(75,100,95);
   try {
      if (pix1 == pix2) { throw err; }
      if (!(pix1 != pix2)) { throw err; }
      itPassed(desc);
   }
   catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_5()
{
   string desc = "pix1 != pix2, blue color value different";
   Pixel pix1(75,85,95);
   Pixel pix2(75,85,100);
   try {
      if (pix1 == pix2) { throw err; }
      if (!(pix1 != pix2)) { throw err; }
      itPassed(desc);
   }
   catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_6()
{
   string desc = "pix1 != pix2, all color values different";
   Pixel pix1(75,85,95);
   Pixel pix2(175,185,195);
   try {
      if (pix1 == pix2) { throw err; }
      if (!(pix1 != pix2)) { throw err; }
      itPassed(desc);
   }
   catch(string s) { itFailed(desc + " " + s); }
}

// test stream I/O 
void test_stream_output_1()
{
   string desc = "test pixel stream output";

   // 1. Create local variables:
   //      - a stringstream for input, called "in"
   //      - a stringstream for output, called "out"
   //      - a Pixel called "pix"
   //      - a string called "correct" for storing the expected output for "pix"
   // 2. Store the expected output in the string variable "correct"

   stringstream in, out;
   Pixel pix(50, 100, 225);
   string correct = "50 100 225";

   try {
      // 3. Use the output stream variable "out" and the operator "<<" to
      //    (hopefully) put the expected output for Pixel variable "pix"
      //    into "out".
      // 4. Inside an assert, test whether the result of "out.str()"
      //    (.str() converts stream to string) equals the expected output
      //    in the variable "correct".

      out << pix;
      string actual = out.str();
      if(actual != correct) { throw err; }
      itPassed(desc);
   }
   catch(string s) { itFailed(desc + " " + s); }
}

void test_stream_input_1()
{
   string desc = "test pixel stream input ";
   stringstream in, out;
   Pixel pix(50, 100, 200);
   string correct;

   // 5. To test stream input, use the input stream variable "in" and the
   //    operator "<<" to store an appropriate output representation for
   //    a pixel.  NOTE: Use different RGB values than were used originally
   //    for the Pixel variable "pix".

   in << "10 15 20";

   try {

      // 6. Use the input stream variable "in" and the operator ">>" to
      //    change the value of "pix".

      in >> pix;

      // 7. Use asserts to test that the attributes of "pix" were changed
      //    correctly.

      if(pix.getRed() != 10) { throw err; }
      if(pix.getGreen() != 15) { throw err; }
      if(pix.getBlue() != 20) { throw err; }
      itPassed(desc);
   }
   catch(string s) { itFailed(desc + " " + s); }
}


int main() {
   print("\nTests for Pixel basic functionality ...");
   test_constructor_1();
   test_constructor_2();
   test_constructor_3();
   test_constructor_4();
   test_setters_1();
   test_setters_2();
   test_setters_3();
   test_setters_4();
   print("\n*** Pixel basic functionality tests finished. ***");

   print("\nTests for Pixel operator overloading ...");
   test_eq_noteq_1();
   test_eq_noteq_2();
   test_eq_noteq_3();
   test_eq_noteq_4();
   test_eq_noteq_5();
   test_eq_noteq_6();
   test_stream_output_1();
   test_stream_input_1();
   print("\n*** Pixel operator overloading tests finished. ***");

   // ======================== SUMMARY INFORMATION ====================== //
   int num_tests = tests_passed + tests_failed;
   double passed = (double) tests_passed;
   double total = (double) num_tests;
   cout << "\nNumber of segmentation faults encountered during testing = "
        << segmentation_faults << endl;
   cout << "Number of infinite loops encountered during testing = "
        << infinite_loops << endl;
   cout << "Number of tests passed = " << tests_passed << " out of "
        << num_tests << endl;
   cout << "Number of tests failed = " << tests_failed << " out of "
        << num_tests << endl;
   cout << "Percent of tests passed = " << (100 * passed / total)
        << "%" << endl << endl;

   return 0;
}
