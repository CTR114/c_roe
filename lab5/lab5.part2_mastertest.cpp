// lab5.part2_mastertest.cpp
// Tests for Sequence class
// Barb Wahl, 2-8-16 -- revised 3-2-2017

// NOTE:  Execution of student code will still be halted by fatal errors such
// as segmentation faults and infinite loops.  Make use of the methods
// `segFault` and `infiniteLoop` in these situations.

// NOTE:  As much as possible, use only *basic* functionality in implementing
// testing code.

// NOTE:  Since the testing code is implemented using the student's
// implementations for basic functionality (part 1), any problems in basic 
// functionality must be "patched" by the instructor (after recording the 
// relevant info) before re-running the tests.  Save the altered code as, for 
// example, Sequence_patched.cpp, then re-compile to evaluate non-basic 
// functionality.

// ========================= Testing Boilerplate =========================
#include <cassert>
#include <sstream>
#include <iostream>
#include <string>
#include "Sequence.h"

using namespace std;
using namespace main_savitch_3;

extern string EXC_OUT_OF_BOUNDS;
extern string EXC_LIST_NOT_ORDERED;

const string err = "";
int tests_passed = 0;
int tests_failed = 0;
int segmentation_faults = 0;
int infinite_loops = 0;

// print method
// prints the given string plus endl
void print(string str) {
     cout << str << endl;
}

// segFault method
// When student code creates a segmentation fault, comment out the corresponding
// test call in main and *insert* a call to segFault.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// segmentation_faults counter.
void segFault(string desc) {
     print("### TEST FAILED ###: " + desc + "; segmentation fault");
     tests_failed++;
     segmentation_faults++;
}

// infiniteLoop method
// When student code creates an infinite loop, comment out the corresponding
// test call in main and *insert* a call to infiniteLoop.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// infinite_loops counter.
void infiniteLoop(string desc) {
     print("### TEST FAILED ###: " + desc + "; infinite loop");
     tests_failed++;
     infinite_loops++;
}

// itFailedToThrowCorrectException method
// input: string desc, describes the test which was run
void itFailedToThrowCorrectException(string desc) {
     print("### TEST FAILED ###: " + desc + "; threw non-string exeception");
     tests_failed++;
}

// itFailed method
// ## always call this method when a test fails, except when the code under
// test threw the *wrong* exception -- see `itFailedToThrowCorrectException` ##
// prints message for failed test
// increments the count of failed tests
void itFailed(string str) {
     print("### TEST FAILED ###: " + str);
     tests_failed++;
}

// itPassed method
// ## always call this method when a test passes ##
// prints message for passed test
// increments the count of passed tests
void itPassed(string str) {
     print("TEST PASSED: " + str);
     tests_passed++;
}

// stripSpaceAndMakeLowerCase function
// input:  string s
// output: string
//
// makes a copy of string s, strips ' ' and '\n' from
// the copy, and changes all remaining chars to lower case
//
// returns this altered copy of the string
//
// leaves the original string s unchanged
string stripSpacesAndMakeLowerCase(string s)
{
     string str = s;
     for (unsigned int i = 0; i < str.length(); i++)
     {
         if (str[i] == ' ' || str[i] == '\n') 
         {
             str.erase(i, 1);
             i--;
         } else { 
             str[i] = tolower(str[i]); 
         }
     }
     return str;
}

// laxString method
// use for comparing strings generated by stream output (<<)
// ignores whitespace, including newlines
// return:  true iff s1 and s2 are equivalent after ignoring whitespace
bool laxString(string s1, string s2)
{
     string x = stripSpacesAndMakeLowerCase(s1);
     string y = stripSpacesAndMakeLowerCase(s2);
     return x == y;
}

// ========================= Tests =========================

// ** FOR LAB 5 PART 2 ** //

// INSERT
// The provided value, `entry`, has been inserted in the sequence
// _before_ the current item.
// If there was no current item, then the new entry
// has been inserted at the _front_ of the sequence.
// In either case, the newly inserted item IS NOW THE CURRENT ITEM of the
// sequence. 
void test_insert_1()
{
    string desc = "insert into an empty sequence (prepend)";
    Sequence s1;
    try{
        s1.insert('a');
        // s1 should now have one item, 'a', and it's the current item
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 1)) { throw err; }
        if (!(s1.current() == 'a')) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_insert_2()
{
    string desc = "insert into a list of length 1, current_index == 0";
    Sequence s1;
    s1.append('a');
    s1.start();
    try{
        s1.insert('b');
        // s1 should now have two items:  (b, a) with current() == 'b'
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 2)) { throw err; }
        if (!(s1.current() == 'b')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'a')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_insert_3()
{
    string desc = "insert into a list of length 1, current_index == 1";
    Sequence s1;
    s1.append('a');
    s1.advance();  // (a), index == 1
    try{
        s1.insert('b');
        // s1 should now have two items:  (b, a) with current() == 'b'
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 2)) { throw err; }
        if (!(s1.current() == 'b')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'a')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_insert_4()
{
    string desc = "insert into a list of length 2, current_index == 0";
    Sequence s1;
    s1.append('b');
    s1.append('a');
    s1.start();     // (b, a)
    try{
        s1.insert('c');  // should be (c, b, a)
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 3)) { throw err; }
        if (!(s1.current() == 'c')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'b')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'a')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_insert_5()
{
    string desc = "insert into a list of length 2, current_index == 1";
    Sequence s1;
    s1.append('a');
    s1.append('b');  // (a, b)
    s1.start();
    s1.advance();   // (a, b); current_index == 1
    try {
        s1.insert('x');  // (a, x, b) with x = current
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 3)) { throw err; }
        if (!(s1.current() == 'x')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'b')) { throw err; }
        s1.start();
        if (!(s1.current() == 'a')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_insert_6()
{
    string desc = "insert into a list of length 3, no current item";
    Sequence s1;
    s1.append('a');
    s1.append('x');
    s1.append('b');
    s1.advance();
    try {
        s1.insert('t');  // (t, a, x, b), t = current
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 4)) { throw err; }
        if (!(s1.current() == 't')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'a')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'x')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'b')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_insert_7()
{
    string desc = 
        "insert into a list of length CAPACITY - 1, current_index == 0";
    Sequence L;
    for (int i = 0; i < Sequence::CAPACITY - 1; i++)
    {
        L.append('z');
    }
    L.start();
    try {
        L.insert('a');  // (a, z, z, ..., z)
        if (!(L.current() == 'a')) { throw err; }
        if (!(L.size() == Sequence::CAPACITY)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_insert_8()
{
    string desc = 
        "insert into a list of length CAPACITY - 1, current_index == 3";
    Sequence L;
    for (int i = 0; i < Sequence::CAPACITY - 1; i++)
    {
        L.append('z');
    }
    L.start(); L.advance(); L.advance(); L.advance();  // index == 3
    try{
        L.insert('a');  // (z z z a z z z .... z);
        if (!(L.current() == 'a')) { throw err; }
        if (!(L.size() == Sequence::CAPACITY)) { throw err; }
        L.start();
        for (int i = 0; i < 3; i++) { L.advance(); }
        if (!(L.current() == 'a')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_insert_9()
{
    string desc = 
        "insert into a list of length CAP-1, curr_index == CAP-2";
    Sequence L;
    for (int i = 0; i < Sequence::CAPACITY - 1; i++)
    {
        L.append('z');
    }
    try {
        L.insert('a');  // (z z z .... z z a);
        if (!(L.current() == 'a')) { throw err; }
        if (!(L.size() == Sequence::CAPACITY)) { throw err; }
        L.advance();
        if (!(L.is_item())) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_remove_1()
{
    string desc = "remove from list of length 1";
    Sequence s1;
    s1.append('a');
    try {
        s1.remove_current();
        if (!(s1.size() == 0)) { throw err; }
        if (!(!s1.is_item())) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_remove_2()
{
    string desc = "remove from list of length 2, current = item 0";
    Sequence s1;
    s1.append('a');
    s1.append('b');
    s1.start();
    try {
        s1.remove_current();
        if (!(s1.size() == 1)) { throw err; }
        if (!(s1.current() == 'b')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_remove_3()
{
    string desc = "remove from list of length 2, current = item 1";
    Sequence s1;
    s1.append('a');
    s1.append('b');
    s1.start();
    s1.advance();
    try {
        s1.remove_current();
        if (!(s1.size() == 1)) { throw err; }
        if (!(!s1.is_item())) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_remove_4()
{
    string desc = "remove from list of length 3, current = item 0";
    Sequence s1;
    s1.append('a');
    s1.append('b');
    s1.append('c');
    s1.start();
    try {
        s1.remove_current();
        if (!(s1.size() == 2)) { throw err; }
        if (!(s1.current() == 'b')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_remove_5()
{
    string desc = "remove from list of length 3, current = item 2";
    Sequence s1;
    s1.append('a');
    s1.append('b');
    s1.append('c');
    s1.start();
    s1.advance();
    s1.advance();
    try {
        s1.remove_current();
        if (!(s1.size() == 2)) { throw err; }
        if (!(!s1.is_item())) { throw err; }
        s1.start();
        if (!(s1.current() == 'a')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'b')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_remove_6()
{
    string desc = "remove from list of length CAPACITY, current = 0";
    int array[Sequence::CAPACITY];
    for (int i = 0; i < Sequence::CAPACITY; i++)
    {
        // fill the array starting with ASCII = 60 (<)
        array[i] = i + 60;
    }
    Sequence L;  // long!
    for (int i = 0; i < Sequence::CAPACITY; i++)
    {
        L.append((char)array[i]);
    }
    L.start();
    L.advance();
    char c = L.current();  // remember char at index 1
    L.start();
    try {
        L.remove_current();   // remove from index 0
        if (!(L.current() == c)) { throw err; }
        if (!(L.size() == Sequence::CAPACITY - 1)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_remove_7()
{
    string desc = "remove from list of length CAPACITY, current = 10";
    int array[Sequence::CAPACITY];
    for (int i = 0; i < Sequence::CAPACITY; i++)
    {
        // fill the array starting with ASCII = 60 (<)
        array[i] = i + 60;
    }
    Sequence L;  // long!
    for (int i = 0; i < Sequence::CAPACITY; i++)
    {
        L.append((char)array[i]);
    }
    L.start();
    for (int i = 0; i < 11; i++)
    {
        L.advance();
    }
    // index 11
    char c = L.current();
    L.start();
    for (int i = 0; i < 10; i++)
    {
        L.advance();
    }
    // index 10
    try {
        L.remove_current();
        if (!(L.current() == c)) { throw err; }
        if (!(L.size() == Sequence::CAPACITY - 1)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_remove_8()
{
    string desc = 
        "remove from list of length CAPACITY, current item next-to-last";
    int array[Sequence::CAPACITY];
    for (int i = 0; i < Sequence::CAPACITY; i++)
    {
        // fill the array starting with ASCII = 60 (<)
        array[i] = i + 60;
    }
    Sequence L;  // long!
    for (int i = 0; i < Sequence::CAPACITY; i++)
    {
        L.append((char)array[i]);
    }
    // index is CAPACITY - 1
    char c = L.current();  // c == last item
    L.start();
    for (int i = 0; i < Sequence::CAPACITY - 2; i++)
    {
        L.advance();
    }
    // index is CAPACITY - 2, next-to-last item
    try {
        L.remove_current();
        if (!(L.is_item())) { throw err; }
        if (!(L.size() == Sequence::CAPACITY - 1)) { throw err; }
        if (!(L.current() == c)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

// == operator and != operator

void test_eq_noteq_1()
{
    string desc = "x == x, x empty";
    Sequence s1;
    try {
        if (!(s1 == s1)) { throw err; }
        if (s1 != s1) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_2()
{
    string desc = "() == (), different objects";
    Sequence s1;
    Sequence s2;
    try {
        if (!(s1 == s2)) { throw err; }
        if (s1 != s2) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_3()
{
    string desc = "(a) != ()";
    Sequence s1;
    Sequence s2;
    s1.append('a');
    try {
        if (s1 == s2) { throw err; }
        if (!(s1 != s2)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_4()
{
    string desc = "x == x, length 1";
    Sequence s1;
    try {
        if (!(s1 == s1)) { throw err; }
        if (s1 != s1) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_5()
{
    string desc = "(a) == (a), different objects";
    Sequence s1;
    Sequence s2;
    s1.append('a');
    s2.append('a');
    try {
        if (!(s1 == s2)) { throw err; }
        if (s1 != s2) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_6()
{
    string desc = "(a) != (b)";
    Sequence s1;
    Sequence s2;
    s1.append('a');
    s2.append('b');
    try {
        if (s1 == s2) { throw err; }
        if (!(s1 != s2)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_7()
{
    string desc = "x == x, length 2";
    Sequence s1;
    s1.append('a');
    s1.append('b');
    try {
        if (!(s1 == s1)) { throw err; }
        if (s1 != s1) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_8()
{
    string desc = 
        "(a, b) == (a, b), different objects, different current_index values";
    Sequence s1;
    Sequence s2;
    s1.append('a'); s1.append('b');
    s2.append('a'); s2.append('b');
    try {
        if (!(s1 == s2)) { throw err; }
        if (s1 != s2) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_9()
{
    string desc = "(a, b) != (c, b)";
    Sequence s1;
    Sequence s2;
    s1.append('a'); s1.append('b');
    s2.append('c'); s2.append('b');
    try {
        if (s1 == s2) { throw err; }
        if (!(s1 != s2)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_10()
{
    string desc = "(a, b) != (a, d)";
    Sequence s1;
    Sequence s2;
    s1.append('a'); s1.append('b');
    s2.append('a'); s2.append('d');
    try {
        if (s1 == s2) { throw err; }
        if (!(s1 != s2)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_11()
{
    string desc = "(z, b, c, d) != (a, b, c, d)";
    Sequence s1;
    Sequence s2;
    s1.append('z'); s1.append('b'); s1.append('c'); s1.append('d');
    s2.append('a'); s2.append('b'); s2.append('c'); s2.append('d');
    try {
        if (s1 == s2) { throw err; }
        if (!(s1 != s2)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_eq_noteq_12()
{
    string desc = "(a, b, c, z) != (a, b, c, d)";
    Sequence s1;
    Sequence s2;
    s1.append('z'); s1.append('b'); s1.append('c'); s1.append('z');
    s2.append('a'); s2.append('b'); s2.append('c'); s2.append('d');
    try {
        if (s1 == s2) { throw err; }
        if (!(s1 != s2)) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

// + operator and += operator
void test_add_two_ways_0()
{
    string desc = "test +: length 0 plus length 0";
    Sequence s1;
    Sequence s2;
    try {
        Sequence s3 = s1 + s2;  // s3 = ()
        if (s3.size() != 0) { throw err; }
        if (s3.is_item()) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_add_two_ways_1()
{
    string desc = "test +: length 1 plus length 2";
    Sequence s1;
    s1.append('c');
    Sequence s2;
    s2.append('a');
    s2.append('t');
    try {
        Sequence s3 = s1 + s2;  // s3 = (c, a, t); current item c
        if (!(s3.size() == 3)) { throw err; }
        if (!(s3.is_item())) { throw err; }
        if (!(s3.current() == 'c')) { throw err; }
        s3.advance();
        if (!(s3.current() == 'a')) { throw err; }
        s3.advance();
        if (!(s3.current() == 't')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_add_two_ways_1A()
{
    string desc = "test +: length CAPACITY - 5, plus length 5";
    Sequence s1;
    int array[Sequence::CAPACITY];
    for (int i = 0; i < Sequence::CAPACITY; i++)
    {
        // fill the array starting with ASCII = 60 (<)
        array[i] = i + 60;
    }
    for (int i = 0; i < Sequence::CAPACITY - 5; i++)
    {
        s1.append((char)array[i]);
    }
    Sequence s2;
    s2.append('1');
    s2.append('2');
    s2.append('3');
    s2.append('4');
    s2.append('5');
    try {
        Sequence s3 = s1 + s2;
        if (!(s3.size() == Sequence::CAPACITY)) { throw err; }
        if (!(s3.is_item())) { throw err; }
        for (int i = 0; i < Sequence::CAPACITY - 5; i++)
        {
          if (!(s3.current() == array[i])) { throw err; }
          s3.advance();
        }
        if (!(s3.current() == '1')) { throw err; }
        s3.advance();
        if (!(s3.current() == '2')) { throw err; }
        s3.advance();
        if (!(s3.current() == '3')) { throw err; }
        s3.advance();
        if (!(s3.current() == '4')) { throw err; }
        s3.advance();
        if (!(s3.current() == '5')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_add_two_ways_2()
{
    string desc = "test +=:  length 1 plus length 2";
    Sequence s1;
    s1.append('c');
    Sequence s2;
    s2.append('a');
    s2.append('t');
    try {
        s1 += s2;
        if (!(s1.size() == 3)) { throw err; }
        if (!(s1.is_item())) { throw err; }
        if (!(s1.current() == 'c')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'a')) { throw err; }
        s1.advance();
        if (!(s1.current() == 't')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_add_two_ways_3()
{
    string desc = "test x += y followed by x += z";
    Sequence x;
    x.append('a');
    x.append('b');
    x.start();  // (a, b), current is a
    Sequence y;
    y.append('c');
    y.append('d');  // (c, d), current is d
    Sequence z;
    z.append('e');
    z.append('f');  //  (e, f), current is f
    try {
        x += y;
        x += z;
        // x is (a b c d e f) with current item a
        if (!(x.current() == 'a')) { throw err; }
        if (!(x.size() == 6)) { throw err; }
        x.advance();
        if (!(x.current() == 'b')) { throw err; }
        x.advance();
        if (!(x.current() == 'c')) { throw err; }
        x.advance();
        if (!(x.current() == 'd')) { throw err; }
        x.advance();
        if (!(x.current() == 'e')) { throw err; }
        x.advance();
        if (!(x.current() == 'f')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_add_two_ways_4()
{
    string desc = "test +=: t += t (add sequence to itself)";
    Sequence t;
    t.append('a');
    t.append('b');
    try {
        t += t;     // t should have items (a, b, a, b) 
                   // and current item the first 'b'
        if (!(t.size() == 4)) { throw err; }
        if (!(t.is_item())) { throw err; }
        if (!(t.current() == 'b')) { throw err; }  // index 1
        t.advance();
        if (!(t.current() == 'a')) { throw err; }  // index 2
        t.advance();
        if (!(t.current() == 'b')) { throw err; }  // index 3
        // check index 0
        t.start();
        if (!(t.current() == 'a')) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

// test stream I/O for typical sequences
// All tests are provided.

void test_stream_output_1()
{
    string desc = "test stream output for typical sequences";
    // 1. Create local variables:
    //  - a stringstream for input, called in
    //  - a stringstream for output, called out
    //  - a string for storing the expected message, called correct
    //  - a Sequence with specific name and age, called p
    stringstream in, out;
    string correct;
    Sequence seq;
    seq.append('h');
    seq.append('i');
    seq.append('!');
    seq.start();

    // 2. Store the expected message in the string variable "correct"
    // Get it exactly right!
    correct = "sequence: h i !";
    try {
        // 3. Use the output stream variable "out" and the operator "<<" to
        // (hopefully) put the expected message for seq into the stream
        out << seq;

        // 4. Inside an assert, test whether the "out.str()" result
        // (.str() converts stream to string) equals the expected message string
        string actual = out.str();
        if (actual != correct) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_stream_output_2()
{
    string desc = "test stream output for empty sequences";
    // 1. Create local variables:
    //  - a stringstream for input, called in
    //  - a stringstream for output, called out
    //  - a string for storing the expected message, called correct
    //  - a Sequence with specific name and age, called p
    stringstream in, out;
    string correct;
    Sequence seq;

    // 2. Store the expected message in the string variable "correct"
    // Get it exactly right!
    correct = "sequence: <empty sequence>";
    try {
        // 3. Use the output stream variable "out" and the operator "<<" to
        // (hopefully) put the expected message for seq into the stream
        out << seq;

        // 4. Inside an assert, test whether the "out.str()" result
        // (.str() converts stream to string) equals the expected message string
        string actual = out.str();
        if (actual != correct) { throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_stream_input_1()
{
    string desc = "test stream input for typical sequences";
    stringstream in, out;
    string correct;
    // 5. To test stream input, use the input stream variable "in" and the
    // operator "<<" to store an appropriate message such as,
    in << "sequence: c a t s";

    // 6. Use the input stream variable "in" and the operator ">>" to
    // change seq
    Sequence seq;
    for (int i = 0; i < 10; i++) { seq.append('x'); }
    try {
        in >> seq;

        // 7. Use asserts to test that the attributes of seq
        // have been modified as expected
        assert(seq.size() == 4);
        assert(seq.current() == 'c');  // >> should move curr_index to start
        seq.advance();
        assert(seq.current() == 'a');
        seq.advance();
        assert(seq.current() == 't');
        seq.advance();
        assert(seq.current() == 's');
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

void test_stream_input_2()
{
    string desc = "test stream input for empty sequences";
    stringstream in, out;
    string correct;
    // 5. To test stream input, use the input stream variable "in" and the
    // operator "<<" to store an appropriate message.
    in << "sequence: <empty sequence>";

    // 6. Use the input stream variable "in" and the operator ">>" to
    // change seq
    Sequence seq;
    for (int i = 0; i < 10; i++) { seq.append('x'); }
    try {
        in >> seq;

        // 7. Use asserts to test that the attributes of seq
        // have been modified as expected
        if (seq.size() != 0) { throw err; }
        if (seq.is_item()) {throw err; }
        itPassed(desc);
    }
    catch(string s) { itFailed(desc + " " + s); }
}

int main() 
{
    print("\ntests for Lab 5 Part 2 functions ...");
    test_insert_1();
    test_insert_2();
    test_insert_3();
    test_insert_4();
    test_insert_5();
    test_insert_6();
    test_insert_7();
    test_insert_8();
    test_insert_9();

    test_remove_1();
    test_remove_2();
    test_remove_3();
    test_remove_4();
    test_remove_5();
    test_remove_6();
    test_remove_7();
    test_remove_8();

    test_eq_noteq_1();
    test_eq_noteq_2();
    test_eq_noteq_3();
    test_eq_noteq_4();
    test_eq_noteq_5();
    test_eq_noteq_6();
    test_eq_noteq_7();
    test_eq_noteq_8();
    test_eq_noteq_9();
    test_eq_noteq_10();
    test_eq_noteq_11();
    test_eq_noteq_12();

    test_add_two_ways_0();
    test_add_two_ways_1();
    test_add_two_ways_1A();
    test_add_two_ways_2();
    test_add_two_ways_3();
    test_add_two_ways_4();

    test_stream_output_1();
    test_stream_output_2();
    test_stream_input_1();
    test_stream_input_2();

    // ======================== SUMMARY INFORMATION ====================== //
    int num_tests = tests_passed + tests_failed;
    double passed = (double) tests_passed;
    double total = (double) num_tests;
    cout << "\nNumber of segmentation faults encountered during testing = "
         << segmentation_faults << endl;
    cout << "Number of infinite loops encountered during testing = "
         << infinite_loops << endl;
    cout << "Number of tests passed = " << tests_passed << " out of "
         << num_tests << endl;
    cout << "Number of tests failed = " << tests_failed << " out of "
         << num_tests << endl;
    cout << "Percent of tests passed = " << (100 * passed / total)
         << "%" << endl << endl;

    return 0;
}
