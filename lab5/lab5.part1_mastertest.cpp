// lab5.part1_mastertest.cpp
// Tests for Sequence class
// Barb Wahl, 2-8-16 -- revised 3-2-2017

// NOTE:  Execution of student code will still be halted by fatal errors such
// as segmentation faults and infinite loops.  Make use of the methods
// `segFault` and `infiniteLoop` in these situations.

// NOTE:  As much as possible, use only *basic* functionality in implementing
// testing code.

// NOTE:  Since the testing code is implemented using the student's
// implementations for basic functionality (part 1), any problems in basic
// functionality must be "patched" by the instructor (after recording the
// relevant info) before re-running the tests.  Save the altered code as, for
// example, Sequence_patched.cpp, then re-compile to evaluate non-basic
// functionality.

// ========================= Testing Boilerplate =========================
#include <cassert>
#include <sstream>
#include <iostream>
#include <string>
#include "Sequence.h"

using namespace std;
using namespace main_savitch_3;

extern string EXC_OUT_OF_BOUNDS;
extern string EXC_LIST_NOT_ORDERED;

const string err = "";
int tests_passed = 0;
int tests_failed = 0;
int segmentation_faults = 0;
int infinite_loops = 0;

// print method
// prints the given string plus endl
void print(string str) {
     cout << str << endl;
}

// segFault method
// When student code creates a segmentation fault, comment out the corresponding
// test call in main and *insert* a call to segFault.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// segmentation_faults counter.
void segFault(string desc) {
     print("### TEST FAILED ###: " + desc + "; segmentation fault");
     tests_failed++;
     segmentation_faults++;
}

// infiniteLoop method
// When student code creates an infinite loop, comment out the corresponding
// test call in main and *insert* a call to infiniteLoop.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// infinite_loops counter.
void infiniteLoop(string desc) {
     print("### TEST FAILED ###: " + desc + "; infinite loop");
     tests_failed++;
     infinite_loops++;
}

// itFailedToThrowCorrectException method
// input: string desc, describes the test which was run
void itFailedToThrowCorrectException(string desc) {
     print("### TEST FAILED ###: " + desc + "; threw non-string exeception");
     tests_failed++;
}

// itFailed method
// ## always call this method when a test fails, except when the code under
// test threw the *wrong* exception -- see `itFailedToThrowCorrectException` ##
// prints message for failed test
// increments the count of failed tests
void itFailed(string str) {
     print("### TEST FAILED ###: " + str);
     tests_failed++;
}

// itPassed method
// ## always call this method when a test passes ##
// prints message for passed test
// increments the count of passed tests
void itPassed(string str) {
     print("TEST PASSED: " + str);
     tests_passed++;
}

// stripSpaceAndMakeLowerCase function
// input:  string s
// output: string
//
// makes a copy of string s, strips ' ' and '\n' from
// the copy, and changes all remaining chars to lower case
//
// returns this altered copy of the string
//
// leaves the original string s unchanged
string stripSpacesAndMakeLowerCase(string s)
{
     string str = s;
     for (unsigned int i = 0; i < str.length(); i++)
     {
         if (str[i] == ' ' || str[i] == '\n')
         {
             str.erase(i, 1);
             i--;
         } else {
             str[i] = tolower(str[i]);
         }
     }
     return str;
}

// laxString method
// use for comparing strings generated by stream output (<<)
// ignores whitespace, including newlines
// return:  true iff s1 and s2 are equivalent after ignoring whitespace
bool laxString(string s1, string s2)
{
     string x = stripSpacesAndMakeLowerCase(s1);
     string y = stripSpacesAndMakeLowerCase(s2);
     return x == y;
}

// ========================= Tests =========================

// variables / objects for use cases; don't *change* these objects!

// test part 1 methods together:
//    Sequence (constructor)
//    size
//    is_item
//    current
//    start
//    advance
//    append

// TEST IS_ITEM() CAN BE FALSE ON NON-EMPTY SEQUENCE
void test_part1_functions_0() {
     Sequence s1;
     s1.append('x');
     s1.advance();
     string desc = "is_item() can be false on non-empty sequence";
     try {
         if (s1.is_item() != false) { throw err; }
         itPassed(desc);
     }
     catch(string s){ itFailed(desc + " " + s); }
}
// construct an empty sequence
// use size(), is_item()
void test_part1_functions_1() {
     Sequence s1;
     string desc = "construct an empty sequence";
     try {
         if (s1.size() != 0) { throw err; }
         if (s1.is_item()) { throw err; }
         itPassed(desc);
     }
     catch(string s){ itFailed(desc + " " + s); }
}

// append to an empty sequence
// use current()
void test_part1_functions_2() {
    string desc = "append to an empty sequence";
    Sequence s1;
    s1.append('a');
    // s1 should now have one item, 'a', and it's the current item

    try {
        if (!s1.is_item())
        if (s1.size() != 1) { throw err; }
        if (s1.current() != 'a') { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

// append to a sequence of length 1, current_index was 0
// use start, advance
void test_part1_functions_3() {
    string desc = "append to a sequence of length 1, current_index was 0";
    Sequence s1;
    s1.append('a');
    // s1 = (a)
    s1.append('b');
    try {
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 2)) { throw err; }
        if (!(s1.current() == 'b')) { throw err; }
        s1.start();
        if (!(s1.current() == 'a')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'b')) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

// append to a sequence of length 2, no current item
void test_part1_functions_4() {
    string desc = "append to a sequence of length 2, no current item";
    Sequence s1;
    s1.append('a');
    s1.append('b');
    s1.advance();  // current_index == length
    try {
        s1.append('c');
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 3)) { throw err; }
        if (!(s1.current() == 'c')) { throw err; }
        s1.start();
        if (!(s1.current() == 'a')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'b')) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

// append to a sequence of length 3, current_index == 1
void test_part1_functions_5() {
    string desc = "append to a sequence of length 3, current_index == 1";
    Sequence s1;
    s1.append('a');
    s1.append('b');
    s1.append('c');
    s1.start();
    s1.advance();
    // index = 1
    s1.append('d');
    try {
        if (!(s1.is_item())) { throw err; }
        if (!(s1.size() == 4)) { throw err; }
        if (!(s1.current() == 'd')) { throw err; }
        s1.start();
        if (!(s1.current() == 'a')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'b')) { throw err; }
        s1.advance();
        if (!(s1.current() == 'c')) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

// append CAPACITY times in a row
void test_part1_functions_6() {
    string desc = "append CAPACITY times in a row";
    Sequence L;
    try {
        for (int i = 0; i < Sequence::CAPACITY; i++)
        {
          L.append('z');
        }
        if (!(L.size() == Sequence::CAPACITY)) { throw err; }
        if (!(L.is_item())) { throw err; }
        L.start();
        for (int i = 0; i < Sequence::CAPACITY; i++)
        {
          if (!(L.current() == 'z')) { throw err; }
          L.advance();
        }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

int main()
{
    print("\ntests for Lab 5 Part 1 functions ...");
    test_part1_functions_0();
    test_part1_functions_1();
    test_part1_functions_2();
    test_part1_functions_3();
    test_part1_functions_4();
    test_part1_functions_5();
    test_part1_functions_6();
    print("\n*** Part 1 tests finished. ***");

    // ======================== SUMMARY INFORMATION ====================== //
    int num_tests = tests_passed + tests_failed;
    double passed = (double) tests_passed;
    double total = (double) num_tests;
    cout << "\nNumber of segmentation faults encountered during testing = "
         << segmentation_faults << endl;
    cout << "Number of infinite loops encountered during testing = "
         << infinite_loops << endl;
    cout << "Number of tests passed = " << tests_passed << " out of "
         << num_tests << endl;
    cout << "Number of tests failed = " << tests_failed << " out of "
         << num_tests << endl;
    cout << "Percent of tests passed = " << (100 * passed / total)
         << "%" << endl << endl;

    return 0;
}
