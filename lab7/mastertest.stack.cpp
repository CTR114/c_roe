// mastertest.stack.cpp
// Tests for Circular-array Queue
// Barb Wahl, 2-8-16
// Theresa Wilson, revised 4-18-2017

// NOTE 1:  Make class instance variables public before compiling.

// NOTE 2:  Execution of student code will still be halted by fatal errors such
// as segmentation faults and infinite loops.  Make use of the methods
// `segFault` and `infiniteLoop` in these situations.

// NOTE 3:  As much as possible, use only *basic* functionality in implementing
// testing code.

// NOTE 4:  Since the testing code is implemented using the student's
// implementations for basic functionality (part 1), any problems in basic
// functionality must be "patched" by the instructor (after recording the
// relevant info) before re-running the tests.  Save the altered code as, for
// example, Sequence_patched.cpp, then re-compile to evaluate non-basic
// functionality.

// ========================= Testing Boilerplate =========================
#include <cassert>
#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <stdexcept>
#include "cs223lab.h"
#include "node2.h"
#include "stack.h"

using namespace std;
using namespace main_savitch_7B;
using namespace generic;

const string err = "";
int tests_passed = 0;
int tests_failed = 0;
int segmentation_faults = 0;
int infinite_loops = 0;

// print method now in cs223lab files

// segFault method
// When student code creates a segmentation fault, comment out the corresponding
// test call in main and *insert* a call to segFault.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// segmentation_faults counter.
void segFault(string desc) {
     print("### TEST FAILED ###: " + desc + "; segmentation fault");
     tests_failed++;
     segmentation_faults++;
}

// infiniteLoop method
// When student code creates an infinite loop, comment out the corresponding
// test call in main and *insert* a call to infiniteLoop.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// infinite_loops counter.
void infiniteLoop(string desc) {
     print("### TEST FAILED ###: " + desc + "; infinite loop");
     tests_failed++;
     infinite_loops++;
}

// itFailedToThrowCorrectException method
// input: string desc, describes the test which was run
void itFailedToThrowCorrectException(string desc) {
     print("### TEST FAILED ###: " + desc + "; threw non-string exeception");
     tests_failed++;
}

// itFailed method
// ## always call this method when a test fails, except when the code under
// test threw the *wrong* exception -- see `itFailedToThrowCorrectException` ##
// prints message for failed test
// increments the count of failed tests
void itFailed(string str) {
     print("### TEST FAILED ###: " + str);
     tests_failed++;
}

// itPassed method
// ## always call this method when a test passes ##
// prints message for passed test
// increments the count of passed tests
void itPassed(string str) {
     print("TEST PASSED: " + str);
     tests_passed++;
}

// stripSpaceAndMakeLowerCase function
// input:  string s
// output: string
//
// makes a copy of string s, strips ' ' and '\n' from
// the copy, and changes all remaining chars to lower case
//
// returns this altered copy of the string
//
// leaves the original string s unchanged
string stripSpacesAndMakeLowerCase(string s)
{
     string str = s;
     for (unsigned int i = 0; i < str.length(); i++)
     {
         if (str[i] == ' ' || str[i] == '\n')
         {
             str.erase(i, 1);
             i--;
         } else {
             str[i] = tolower(str[i]);
         }
     }
     return str;
}

// laxString method
// use for comparing strings generated by stream output (<<)
// ignores whitespace, including newlines
// return:  true iff s1 and s2 are equivalent after ignoring whitespace
bool laxString(string s1, string s2)
{
     string x = stripSpacesAndMakeLowerCase(s1);
     string y = stripSpacesAndMakeLowerCase(s2);
     return x == y;
}

// ========================= Tests =========================

void test_default_constructor1()
{
    string testid = "constructor.test.1";
    string desc = "create empty stack, `top_ptr` is NULL";
    cout << "  " << testid << ": ";

    try {
        stack<string> s1;
        if (s1.top_ptr != NULL) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_default_constructor()
{
    cout << "\nTesting stack default constructor"
         << " . . ." << endl;

    // Test 1: create an empty stack, check `top_ptr`
    test_default_constructor1();
}

void test_push1()
{
    string testid = "push.test.1";
    string desc = "push onto empty stack";
    cout << "  " << testid << ": ";

    stack<string> s1;
    try {
        s1.push("aardvark");
        if (s1.top_ptr == NULL) { throw err; }
        if (s1.top_ptr -> data() != "aardvark") { throw err; }
        if (s1.top_ptr -> link() != NULL) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push2()
{
    string testid = "push.test.2";
    string desc = "push onto size-1 stack";
    cout << "  " << testid << ": ";

    stack<string> s1;
    try {
        s1.push("aardvark");
        s1.push("binturong");
        if (s1.top_ptr == NULL) { throw err; }
        if (s1.top_ptr -> data() != "binturong") { throw err; }
        if (s1.top_ptr -> link() == NULL) { throw err; }
        if (s1.top_ptr -> link() -> data() != "aardvark") { throw err; }
        if (s1.top_ptr -> link() -> link() != NULL) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push()
{
    cout << "\nTesting push . . ." << endl;

    // Test 1: push onto empty stack
    test_push1();

    // Test 2: push onto size-1 stack
    test_push2();
}

void test_pop1()
{
    string testid = "pop.test.1";
    string desc = "pop from a size-2 stack";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("aardvark");
    s1.push("binturong");
    try {
        s1.pop();
        if (s1.top_ptr == NULL) { throw err; }
        if (s1.top_ptr -> data() != "aardvark") { throw err; }
        if (s1.top_ptr -> link() != NULL) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_pop2()
{
    string testid = "pop.test.2";
    string desc = "pop from a size-1 stack";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("aardvark");
    try {
        s1.pop();
        if (s1.top_ptr != NULL) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_pop()
{
    cout << "\nTesting pop . . ." << endl;

    // Test 1: pop from a size-2 stack
    test_pop1();

    // Test 2: pop from a size-1 stack
    test_pop2();
}


void test_empty1()
{
    string testid = "empty.test.1";
    string desc = "create empty stack, empty == true";
    cout << "  " << testid << ": ";

    stack<string> s1;
    try {
        if (!s1.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_empty2()
{
    string testid = "empty.test.2";
    string desc = "push 1x, empty == false";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("wombat");
    try {
        if (s1.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_empty()
{
    cout << "\nTesting empty" << " . . ." << endl;

    // Test 1: create empty stack, empty == true
    test_empty1();

    // Test 2: push 1x, empty == false
    test_empty2();
}

void test_size1()
{
    string testid = "size.test.1";
    string desc = "create empty stack, size == 0";
    cout << "  " << testid << ": ";

    stack<string> s1;
    try {
        if (s1.size() != 0) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size2()
{
    string testid = "size.test.2";
    string desc = "push 1x, size == 1";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("wombat");
    try {
        if (s1.size() != 1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size3()
{
    string testid = "size.test.3";
    string desc = "push 1x, pop 1x size == 0";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("aardvark");
    s1.pop();
    try {
        if (s1.size() != 0) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size4()
{
    string testid = "size.test.4";
    string desc = "push 5x, size == 5";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("aardvark");
    s1.push("binturong");
    s1.push("okapi");
    s1.push("wombat");
    s1.push("zebra");
    try {
        if (s1.size() != 5) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size5()
{
    string testid = "size.test.5";
    string desc = "push 5x, pop 3x size == 2";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("aardvark");
    s1.push("binturong");
    s1.push("okapi");
    s1.push("wombat");
    s1.push("zebra");
    s1.pop();
    s1.pop();
    s1.pop();
    try {
        if (s1.size() != 2) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size()
{
    cout << "\nTesting size" << " . . ." << endl;

    // Test 1: create empty stack, size == 0
    test_size1();

    // Test 2: push 1x, size == 1
    test_size2();

    // Test 3: push 1x, pop 1x, size == 0
    test_size3();

    // Test 4: push 1x, pop 1x, size == 0
    test_size3();

    // Test 5: push 5x, pop 3x size == 2
    test_size5();
}

void test_top1()
{
    string testid = "top.test.1";
    string desc = "push 1x, check top";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("wombat");
    try {
        if (s1.top() != "wombat") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_top2()
{
    string testid = "top.test.2";
    string desc = "push 2x, pop 1x, check top";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("wombat");
    s1.push("zebra");
    s1.pop();
    try {
        if (s1.top() != "wombat") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_top3()
{
    string testid = "top.test.3";
    string desc = "push 5x, check top";
    cout << "  " << testid << ": ";

    stack<string> s1;
    try {
        s1.push("aardvark");
        if (s1.top() != "aardvark") { throw err; }
        s1.push("binturong");
        if (s1.top() != "binturong") { throw err; }
        s1.push("okapi");
        if (s1.top() != "okapi") { throw err; }
        s1.push("wombat");
        if (s1.top() != "wombat") { throw err; }
        s1.push("zebra");
        if (s1.top() != "zebra") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_top4()
{
    string testid = "top.test.4";
    string desc = "push and pop many different items, top always correct";
    cout << "  " << testid << ": ";

    stack<string> s1;
    try {
        for (int i = 0; i < 50; i++)
        {
            s1.push(generic::to_string(i));
            if (s1.top() != generic::to_string(i)) { throw err; }
            s1.pop();
        }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_top()
{
    cout << "\nTesting top" << " . . ." << endl;

    // Test 1: push 1x, check top
    test_top1();

    // Test 2: push 2x, check top
    test_top2();

    // Test 3: push 5x, check top
    test_top3();

    // Test 4: push and pop many different items, top always correct
    test_top4();
}

void test_copy_constructor1()
{
    string testid = "cpyconstr.test.1";
    string desc = "empty stack";
    cout << "  " << testid << ":";  

    stack<string> s1;
    try {
        stack<string> s2(s1);
        if (!s2.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_copy_constructor2()
{
    string testid = "cpyconstr.test.2";
    string desc = "1-item stack";  // NOLINT
    cout << "  " << testid << ":";  

    stack<string> s1;
    s1.push("ziggy");

    try {
        stack<string> s2(s1);
        if (s2.top() != "ziggy") { throw err; }
        if (s2.size() != 1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_copy_constructor3()
{
    string testid = "cpyconstr.test.3";
    string desc = "many pushes/pops to make size 3 before copying";  // NOLINT
    cout << "  " << testid << ":";  

    stack<string> s1;
    string str;

    for (int i = 0; i < 15; i++)
    {
        str = generic::to_string(i);
        s1.push(str);
    }

    for (int i = 0; i < 15; i++)
    {
        str = generic::to_string(i);
        s1.pop();
    }
    assert(s1.empty());

    s1.push("eat");
    s1.push("more");
    s1.push("vegetables");

    try {
        stack<string> s2(s1);   // activate the copy constructor
        if (s2.top() != "vegetables") { throw err; }
        s2.pop();
        if (s2.top() != "more") { throw err; }
        s2.pop();
        if (s2.top() != "eat") { throw err; }
        s2.pop();
        if (!s2.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_copy_constructor()
{
    cout << "\nTesting automatic copy constructor" << " . . ." << endl;

    // Test 1: copy an empty stack
    test_copy_constructor1();

    // Test 2: copy a stack of length 1, with first at index 0
    test_copy_constructor2();

    // Test 3: copy a typical stack
    test_copy_constructor3();
}

void test_exceptions1()
{
    string test = "  exceptions.test.1: when popping an empty stack";
    cout << test;

    try {
        stack<string> s1;
        s1.pop();       // should throw domain_error
    } catch (domain_error&  e) {
        cout << " ... ok" << endl;
        return;
    }
    assert(false);      // shouldn't make it here;
}

void test_exceptions2()
{
    string test = "  exceptions.test.2: when toping an empty stack";
    cout << test;

    try {
        stack<string> s1;
        s1.top();     // should throw domain_error
    } catch (domain_error&  e) {
        cout << " ... ok" << endl;
        return;
    }
    assert(false);      // shouldn't make it here;
}

void test_exceptions()
{
    cout << "\nTesting that exceptions are thrown when necessary . . ."
         << endl;

    // Test 1: pop an empty stack
    //test_exceptions1();
    string desc = "pop an empty stack";
    segFault(desc);

    // Test 2: top() an empty stack
    test_exceptions2();

    cout << ". . . exception throwing is OK!" << endl;
}

void test_equiv_inequiv1()
{
    string testid = "equneq.test.1";
    string desc = "different sized stacks";
    cout << "  " << testid << ": ";

    // Setup: create differently sized stacks
    string str;
    stack<string> s1;
    for (int i = 0; i < 3; i++)
    {
        str =  generic::to_string(i);
        s1.push(str);
    }
    stack<string> s2;
    for (int i = 0; i < 4; i++)
    {
        str =  generic::to_string(i);
        s1.push(str);
    }

    try {
        if (s1 == s2) { throw err; }
        if (s2 == s1) { throw err; }
        if (!(s1 != s2)) { throw err; }
        if (!(s2 != s1)) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv2()
{
    string testid = "equneq.test.2";
    string desc = "both stacks empty";
    cout << "  " << testid << ": ";

    // Setup: create two empty stacks
    stack<string> s1;
    stack<string> s2;

    try {
        if (!(s1 == s2)) { throw err; }
        if (!(s2 == s1)) { throw err; }
        if (s1 != s2) { throw err; }
        if (s2 != s1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv3()
{
    string testid = "equneq.test.3";
    string desc = "same size, same values, same order";
    cout << "  " << testid << ": ";

    // Setup: create identical stacks, except have the first and last
    //  indexes of the two stacks be different (e.g., same items in 
    //  same order, but in different locations in each stack)
    string str;
    stack<string> s1;
    for (int i = 0; i < 20; i++)
    {
        s1.push("temp");
        s1.pop();
    }
    // s1 is empty, with last=27 and first=28

    stack<string> s2;
    s2.push("temp");
    s2.pop();
    // s1 is empty, with last=1 and first=2

    // put the same items in s1 and s2
    for (int i = 0; i < 6; i++)
    {
        str =  generic::to_string(i);
        s1.push(str);
        s2.push(str);
    }

    try {
        if (!(s1 == s2)) { throw err; }
        if (!(s2 == s1)) { throw err; }
        if (s1 != s2) { throw err; }
        if (s2 != s1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv4()
{
    string testid = "equneq.test.4";
    string desc = "same size, same values, diff order";
    cout << "  " << testid << ": ";

    // Setup: create two stacks with the same items in different orders
    stack<string> s1;
    s1.push("jack");
    s1.push("jill");
    stack<string> s2;
    s2.push("jill");
    s2.push("jack");

    try {
        if (s1 == s2) { throw err; }
        if (s2 == s1) { throw err; }
        if (!(s1 != s2)) { throw err; }
        if (!(s2 != s1)) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv5()
{
    string testid = "equneq.test.5";
    string desc = "same size, diff first value";
    cout << "  " << testid << ": ";

    // Setup: create two stacks that differ only in their first value
    stack<string> s1;
    s1.push("ziggy");
    s1.push("cleo");
    s1.push("skye");
    stack<string> s2;
    s2.push("spike");
    s2.push("cleo");
    s2.push("skye");

    try {
        if (s1 == s2) { throw err; }
        if (s2 == s1) { throw err; }
        if (!(s1 != s2)) { throw err; }
        if (!(s2 != s1)) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv6()
{
    string testid = "equneq.test.6";
    string desc = "same size, diff last value";
    cout << "  " << testid << ": ";

    // Setup: create two stacks that differ only in their last value
    stack<string> s1;
    s1.push("cleo");
    s1.push("skye");
    s1.push("ziggy");
    stack<string> s2;
    s2.push("cleo");
    s2.push("skye");
    s2.push("spike");

    try {
        if (s1 == s2) { throw err; }
        if (s2 == s1) { throw err; }
        if (!(s1 != s2)) { throw err; }
        if (!(s2 != s1)) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv()
{
    cout << "\nTesting equivalence, inequivalence . . ." << endl;

    // Test 1: stacks have different sizes
    test_equiv_inequiv1();

    // Test 2: both stacks empty
    test_equiv_inequiv2();

    // Test 3: stacks have same sizes, same values, same order 
    test_equiv_inequiv3();

    // Test 4: stacks have same sizes, same values, different order
    test_equiv_inequiv4();

    // Test 5: stacks have same sizes, first value differs
    test_equiv_inequiv5();

    // Test 6: stacks have same sizes, last value differs
    test_equiv_inequiv6();
}

void test_reverse1()
{
    string testid = "reverse.test.1";
    string desc = "empty stack";
    cout << "  " << testid << ": ";

    stack<string> s1;

    try {
        s1.reverse();
        if (!(s1.empty())) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse2()
{
    string testid = "reverse.test.2";
    string desc = "stack of size 1";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("ziggy");

    try {
        s1.reverse();
        if (s1.size() != 1) { throw err; }
        if (s1.top() != "ziggy") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse3()
{
    string testid = "reverse.test.3";
    string desc = "stack of size 2";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("ziggy");
    s1.push("spike");
    s1.reverse();
    try {
        if (s1.size() != 2) { throw err; }
        if (s1.top() != "ziggy") { throw err; }
        s1.pop();
        if (s1.top() != "spike") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse4()
{
    string testid = "reverse.test.4";
    string desc = "stack of size 3";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("ziggy");
    s1.push("spike");
    s1.push("cleo");

    try {
        s1.reverse();
        if (s1.size() != 3) { throw err; }
        if (s1.top() != "ziggy") { throw err; }
        s1.pop();
        if (s1.top() != "spike") { throw err; }
        s1.pop();
        if (s1.top() != "cleo") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse5()
{
    string testid = "reverse.test.5";
    string desc = "stack with many items";
    cout << "  " << testid << ": ";

    string str;
    stack<string> s1;
    for (int i = 0; i < 15; i++)
    {
        str =  generic::to_string(i);
        s1.push(str);
    }

    try {
        s1.reverse();
        if (s1.size() != 15) { throw err; }
        for (int i = 0; i < 15; i++)
        {
            str = generic::to_string(i);
            if (s1.top() != str) { throw err; }
            s1.pop();
        }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse()
{
    cout << "\nTesting reverse . . ." << endl;

    // Test 1: reverse an empty stack
    test_reverse1();

    // Test 2: reverse a stack of size 1
    test_reverse2();

    // Test 3: reverse a stack of size 2
    test_reverse3();

    // Test 4: reverse a stack of size 3
    test_reverse4();

    // Test 5: reverse a stack with many items
    test_reverse5();
}

void test_assignment1()
{
    string testid = "assignment.test.1";
    string desc = "stk = empty stack";
    cout << "  " << testid << ": ";

    stack<string> s1;
    stack<string> stk;
    stk.push("aardvark");
    stk.push("bingurong");
    stk.push("cheetah");

    try {
        stk = s1;
        if (!stk.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_assignment2()
{
    string testid = "assignment.test.2";
    string desc = "stk = longer stack";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("aardvark");
    s1.push("bingurong");
    s1.push("cheetah");
    s1.push("dingo");
    s1.push("elephant");

    stack<string> stk;
    stk.push("zebra");

    try {
        stk = s1;
        if (stk != s1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_assignment3()
{
    string testid = "assignment.test.3";
    string desc = "stk = self-assignment works";
    cout << "  " << testid << ": ";

    stack<string> stk;
    stk.push("aardvark");
    stk.push("bingurong");
    stk.push("cheetah");

    try {
        stk = stk;
        if (stk.size() != 3) { throw err; } 
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_assignment4()
{
    string testid = "assignment.test.4";
    string desc = "both stacks are still independent";
    cout << "  " << testid << ": ";

    stack<string> s1;
    s1.push("aardvark");
    s1.push("binturong");

    stack<string> stk;

    try {
        stk = s1;
        stk.pop();
        if (s1.top() != "binturong") { throw err; }
        if (stk.top() != "aardvark") { throw err; }
        s1.push("zebra");
        if (s1.top() != "zebra") { throw err; }
        if (stk.top() != "aardvark") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_assignment_operator()
{
    cout << "\nTesting assignment operator . . ." << endl;

    // Test 1: assign an empty stack to a non-empty stack
    test_assignment1();

    // Test 2: assign a longer stack to a shorter stack
    test_assignment2();

    // Test 3: assign a stack to itself (test self-assignment)
    test_assignment3();

    // Test 4: check independence of stacks
    test_assignment4();
}

void printSummary()
{
    int num_tests = tests_passed + tests_failed;
    double passed = (double) tests_passed;
    double total = (double) num_tests;
    cout << "\nNumber of segmentation faults encountered during testing = "
         << segmentation_faults << endl;
    cout << "Number of infinite loops encountered during testing = "
         << infinite_loops << endl;
    cout << "Number of tests passed = " << tests_passed << " out of "
         << num_tests << endl;
    cout << "Number of tests failed = " << tests_failed << " out of "
         << num_tests << endl;
    cout << "Percent of tests passed = " << (100 * passed / total)
         << "%" << endl << endl;
}

int main()
{
    cout << "\nMASTERTEST Report (stack class)" << endl;
    test_default_constructor();
    test_push();
    test_pop();
    test_empty();
    test_size();
    test_top();

    int basic_failed = tests_failed;
    if (basic_failed > 0)
    {
        string warning = generic::to_string(basic_failed);
        warning += " basic functionality test(s) failed; may need to patch";
        print_warning(warning);
    }

    test_equiv_inequiv();
    test_reverse();
    test_copy_constructor();
    test_assignment_operator();
    test_exceptions();
    
    printSummary();

    return 0;
}
