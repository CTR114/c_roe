// mastertest.queue.cpp
// Tests for Circular-array Queue
// Barb Wahl, 2-8-16
// Theresa Wilson, revised 4-9-2017

// NOTE 1:  Make class instance variables public before compiling.

// NOTE 2:  Execution of student code will still be halted by fatal errors such
// as segmentation faults and infinite loops.  Make use of the methods
// `segFault` and `infiniteLoop` in these situations.

// NOTE 3:  As much as possible, use only *basic* functionality in implementing
// testing code.

// NOTE 4:  Since the testing code is implemented using the student's
// implementations for basic functionality (part 1), any problems in basic
// functionality must be "patched" by the instructor (after recording the
// relevant info) before re-running the tests.  Save the altered code as, for
// example, Sequence_patched.cpp, then re-compile to evaluate non-basic
// functionality.

// ========================= Testing Boilerplate =========================
#include <cassert>
#include <iostream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <stdexcept>
#include "cs223lab.h"
#include "queue.h"

using namespace std;
using namespace main_savitch_8B;
using namespace generic;

const string err = "";
int tests_passed = 0;
int tests_failed = 0;
int segmentation_faults = 0;
int infinite_loops = 0;

// print method now in cs223lab files

// segFault method
// When student code creates a segmentation fault, comment out the corresponding
// test call in main and *insert* a call to segFault.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// segmentation_faults counter.
void segFault(string desc) {
     print("### TEST FAILED ###: " + desc + "; segmentation fault");
     tests_failed++;
     segmentation_faults++;
}

// infiniteLoop method
// When student code creates an infinite loop, comment out the corresponding
// test call in main and *insert* a call to infiniteLoop.
// Use the parameter `desc` to indicate the failing test.
// Result:  prints an appropriate message; increments tests_failed counter and
// infinite_loops counter.
void infiniteLoop(string desc) {
     print("### TEST FAILED ###: " + desc + "; infinite loop");
     tests_failed++;
     infinite_loops++;
}

// itFailedToThrowCorrectException method
// input: string desc, describes the test which was run
void itFailedToThrowCorrectException(string desc) {
     print("### TEST FAILED ###: " + desc + "; threw non-string exeception");
     tests_failed++;
}

// itFailed method
// ## always call this method when a test fails, except when the code under
// test threw the *wrong* exception -- see `itFailedToThrowCorrectException` ##
// prints message for failed test
// increments the count of failed tests
void itFailed(string str) {
     print("### TEST FAILED ###: " + str);
     tests_failed++;
}

// itPassed method
// ## always call this method when a test passes ##
// prints message for passed test
// increments the count of passed tests
void itPassed(string str) {
     print("TEST PASSED: " + str);
     tests_passed++;
}

// stripSpaceAndMakeLowerCase function
// input:  string s
// output: string
//
// makes a copy of string s, strips ' ' and '\n' from
// the copy, and changes all remaining chars to lower case
//
// returns this altered copy of the string
//
// leaves the original string s unchanged
string stripSpacesAndMakeLowerCase(string s)
{
     string str = s;
     for (unsigned int i = 0; i < str.length(); i++)
     {
         if (str[i] == ' ' || str[i] == '\n')
         {
             str.erase(i, 1);
             i--;
         } else {
             str[i] = tolower(str[i]);
         }
     }
     return str;
}

// laxString method
// use for comparing strings generated by stream output (<<)
// ignores whitespace, including newlines
// return:  true iff s1 and s2 are equivalent after ignoring whitespace
bool laxString(string s1, string s2)
{
     string x = stripSpacesAndMakeLowerCase(s1);
     string y = stripSpacesAndMakeLowerCase(s2);
     return x == y;
}

// ========================= Tests =========================

static const std::size_t CAPACITY = queue::CAPACITY;

void test_default_constructor1()
{
    string testid = "constructor.test.1";
    string desc = "create empty queue, `count` is 0";
    cout << "  " << testid << ": ";

    try {
        queue q1;
        if (q1.count != 0) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_default_constructor2()
{
    string testid = "constructor.test.2";
    string desc = "create empty queue, `last` is valid";
    cout << "  " << testid << ": ";

    try {
        queue q1;
        if (q1.last >= CAPACITY) { throw err; };
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_default_constructor3()
{
    string testid = "constructor.test.3";
    string desc = "create empty queue, `first` == `last` + 1";
    cout << "  " << testid << ": ";

    try {
        queue q1;
        if (q1.first !=  (q1.last + 1) % CAPACITY) { throw err; };
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_default_constructor()
{
    cout << "\nTesting queue default constructor"
         << " . . ." << endl;

    // Test 1: create an empty queue, check `count`
    test_default_constructor1();

    // Test 2: create an empty queue, check `last`
    test_default_constructor2();

    // Test 3: create an empty queue, check `first`
    test_default_constructor3();
}

void test_push1()
{
    string testid = "push.test.1";
    string desc = "push onto empty queue, `count` is 1";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        q1.push("aardvark");
        if (q1.count != 1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push2()
{
    string testid = "push.test.2";
    string desc = "push onto empty queue, `first` == `last` ";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        q1.push("aardvark");
        if (q1.first != q1.last) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push3()
{
    string testid = "push.test.3";
    string desc = "push onto empty queue, `data` is correct";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        q1.push("aardvark");
        if (q1.data[q1.first] != "aardvark") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push4()
{
    string testid = "push.test.4";
    string desc = "push onto size-1 queue, `count` is 2";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        q1.push("aardvark");
        q1.push("binturong");
        if (q1.count != 2) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push5()
{
    string testid = "push.test.5";
    string desc = "push onto size-1 queue, `first` == `last` - 1 ";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        q1.push("aardvark");
        q1.push("binturong");
        if (q1.first != (q1.last - 1 + CAPACITY) % CAPACITY) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push6()
{
    string testid = "push.test.6";
    string desc = "push onto size-1 queue, `data` is correct";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        q1.push("aardvark");
        q1.push("binturong");
        if (q1.data[q1.first] != "aardvark") { throw err; }
        if (q1.data[q1.last] != "binturong") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push7()
{
    string testid = "push.test.7";
    string desc = "push CAPACITY-1 different items, `data` is correct";
    cout << "  " << testid << ": ";

    queue q1;
    for (int i = 0; i < CAPACITY; i++)
    {
        q1.push(generic::to_string(i));
    }
    try {
        for (int i = 0; i < CAPACITY; i++)
        {
            if (q1.data[(q1.first+i)%CAPACITY] != generic::to_string(i)) { throw err; }
        }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_push()
{
    cout << "\nTesting push . . ." << endl;

    // Test 1: push onto empty queue, check `count`
    test_push1();

    // Test 2: push onto empty queue, check `last` and `first`
    test_push2();

    // Test 3: push onto empty queue, check `data`
    test_push3();

    // Test 4: push onto size-1 queue, check `count`
    test_push4();

    // Test 5: push onto size-1 queue, check `last` and `first`
    test_push5();

    // Test 6: push onto size-1 queue, check `data`
    test_push6();

    // Test 7: push CAPACITY-1 different items, check `data`
    test_push7();
}

void test_pop1()
{
    string testid = "pop.test.1";
    string desc = "pop from a size-2 queue, `count` is 1";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    q1.push("binturong");
    try {
        q1.pop();
        if (q1.count != 1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_pop2()
{
    string testid = "pop.test.2";
    string desc = "pop from a size-2 queue, `first` == `last`";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    q1.push("binturong");
    try {
        q1.pop();
        if (q1.first != q1.last) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_pop3()
{
    string testid = "pop.test.3";
    string desc = "pop from a size-2 queue, `data` is correct";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    q1.push("binturong");
    try {
        q1.pop();
        if (q1.data[q1.first] != "binturong") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_pop4()
{
    string testid = "pop.test.4";
    string desc = "pop from a size-1 queue, `count` is 0";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    try {
        q1.pop();
        if (q1.count != 0) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_pop5()
{
    string testid = "pop.test.5";
    string desc = "pop from a size-1 queue, `first` == `last` + 1";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    try {
        q1.pop();
        if (q1.first != (q1.last + 1) % CAPACITY) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_pop()
{
    cout << "\nTesting pop . . ." << endl;

    // Test 1: pop from a size-2 queue, check `count`
    test_pop1();

    // Test 2: pop from a size-2 queue, check `last` and `first`
    test_pop2();

    // Test 3: pop from a size-2 queue, check `data`
    test_pop3();

    // Test 4: pop from a size-1 queue, check `count`
    test_pop4();

    // Test 5: pop from a size-1 queue, check `last` and `first`
    test_pop5();
}

void test_circular1()
{
    string testid = "circular.test.1";
    string desc = "push then pop until `last` is CAPACITY-2, push 2x, `last` == 0";
    cout << "  " << testid << ": ";

    queue q1;
    while (q1.last != CAPACITY - 2)
    {
        q1.push("aardvark");
        q1.pop();
    }
    try {
        q1.push("zebra");
        q1.push("zebra");
        if (q1.last != 0) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_circular2()
{
    string testid = "circular.test.2";
    string desc = "push then pop until `last` is CAPACITY-2, push 2x, check `data`";
    cout << "  " << testid << ": ";

    queue q1;
    while (q1.last != CAPACITY - 2)
    {
        q1.push("aardvark");
        q1.pop();
    }
    try {
        q1.push("zebra");
        q1.push("zebra");
        if (q1.data[q1.last] != "zebra") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_circular3()
{
    string testid = "circular.test.3";
    string desc = "push then pop until `last` is CAPACITY-2, push 3x, pop 1x, `first` == 0";
    cout << "  " << testid << ": ";

    queue q1;
    while (q1.last != CAPACITY - 2)
    {
        q1.push("aardvark");
        q1.pop();
    }
    try {
        q1.push("zebra");
        q1.push("zebra");
        q1.push("zebra");
        q1.pop();
        if (q1.first != 0) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_circular()
{
    cout << "\nTesting queue circular functionality"
         << " . . ." << endl;

    // Test 1: push then pop until `last` is CAPACITY-2, push 2x, check `last`
    test_circular1();

    // Test 2: push then pop until `last` is CAPACITY-2, push 2x, check `data`
    test_circular2();

    // Test 3: push then pop until `last` is CAPACITY-2, push 3x, pop 1x, check `first`
    test_circular3();
}

void test_empty1()
{
    string testid = "empty.test.1";
    string desc = "create empty queue, empty == true";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        if (!q1.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_empty2()
{
    string testid = "empty.test.2";
    string desc = "push 1x, empty == false";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("wombat");
    try {
        if (q1.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_empty3()
{
    string testid = "empty.test.3";
    string desc = "push 1x, pop 1x, empty == true";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("wombat");
    q1.pop();
    try {
        if (!q1.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_empty4()
{
    string testid = "empty.test.4";
    string desc = "push 2x, pop 1x, empty == false";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("wombat");
    q1.push("zebra");
    q1.pop();
    try {
        if (q1.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_empty5()
{
    // Make sure students aren't doing something like using (last < first) to
    // check for an empty queue
    string testid = "empty.test.5";
    string desc = "push then pop until `last` is CAPACITY-2, push 2x, empty == false";
    cout << "  " << testid << ": ";

    queue q1;
    while (q1.last != CAPACITY - 2)
    {
        q1.push("wombat");
        q1.pop();
    }
    q1.push("wombat");
    q1.push("zebra");
    try {
        if (q1.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_empty()
{
    cout << "\nTesting empty" << " . . ." << endl;

    // Test 1: create empty queue, empty == true
    test_empty1();

    // Test 2: push 1x, empty == false
    test_empty2();

    // Test 3: push 1x, pop 1x, empty == true
    test_empty3();

    // Test 4: push 2x, pop 1x, empty == false
    test_empty4();

    // Test 5: push then pop until `last` is CAPACITY-2, push 2x, empty == false
    test_empty5();
}

void test_size1()
{
    string testid = "size.test.1";
    string desc = "create empty queue, size == 0";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        if (q1.size() != 0) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size2()
{
    string testid = "size.test.2";
    string desc = "push 1x, size == 1";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("wombat");
    try {
        if (q1.size() != 1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size3()
{
    string testid = "size.test.3";
    string desc = "push 1x, pop 1x size == 0";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    q1.pop();
    try {
        if (q1.size() != 0) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size4()
{
    string testid = "size.test.4";
    string desc = "push 5x, size == 5";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    q1.push("binturong");
    q1.push("okapi");
    q1.push("wombat");
    q1.push("zebra");
    try {
        if (q1.size() != 5) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size5()
{
    string testid = "size.test.5";
    string desc = "push 5x, pop 3x size == 2";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    q1.push("binturong");
    q1.push("okapi");
    q1.push("wombat");
    q1.push("zebra");
    q1.pop();
    q1.pop();
    q1.pop();
    try {
        if (q1.size() != 2) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size6()
{
    // Make sure students aren't doing something like using first and last 
    // to calculate size
    string testid = "size.test.6";
    string desc = "push then pop until `last` is CAPACITY-2, push 2x, size == 2";
    cout << "  " << testid << ": ";

    queue q1;
    while (q1.last != CAPACITY - 2)
    {
        q1.push("wombat");
        q1.pop();
    }
    q1.push("wombat");
    q1.push("zebra");
    try {
        if (q1.size() != 2) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_size()
{
    cout << "\nTesting size" << " . . ." << endl;

    // Test 1: create empty queue, size == 0
    test_size1();

    // Test 2: push 1x, size == 1
    test_size2();

    // Test 3: push 1x, pop 1x, size == 0
    test_size3();

    // Test 4: push 1x, pop 1x, size == 0
    test_size3();

    // Test 5: push 5x, pop 3x size == 2
    test_size5();

    // Test 6: push then pop until `last` is CAPACITY-2, push 2x, size == 2
    test_size6();
}

void test_full1()
{
    string testid = "full.test.1";
    string desc = "push CAPACITY - 1 items, queue not full";
    cout << "  " << testid << ": ";

    queue q1;
    string str;
    for (int i = 0; i < CAPACITY-1; i++)
    {
        str = generic::to_string(i);
        q1.push(str);
    }
    try {
        if (q1.full()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_full2()
{
    string testid = "full.test.2";
    string desc = "push CAPACITY items, queue is full";
    cout << "  " << testid << ": ";

    queue q1;
    string str;
    for (int i = 0; i < CAPACITY; i++)
    {
        str = generic::to_string(i);
        q1.push(str);
    }
    try {
        if (!q1.full()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}


void test_full()
{
    cout << "\nTesting full . . ." << endl;

    // Test 1: queue is not full
    test_full1();

    // Test 2: queue is full
    test_full2();
}


void test_front1()
{
    string testid = "front.test.1";
    string desc = "push 1x, check front";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("wombat");
    try {
        if (q1.front() != "wombat") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_front2()
{
    string testid = "front.test.2";
    string desc = "push 2x, pop 1x, check front";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("wombat");
    q1.push("zebra");
    q1.pop();
    try {
        if (q1.front() != "zebra") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_front3()
{
    string testid = "front.test.3";
    string desc = "push 5x, check front";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("aardvark");
    q1.push("binturong");
    q1.push("okapi");
    q1.push("wombat");
    q1.push("zebra");
    try {
        if (q1.front() != "aardvark") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_front4()
{
    string testid = "front.test.4";
    string desc = "push and pop CAPACITY-1 different items, front always correct";
    cout << "  " << testid << ": ";

    queue q1;
    try {
        for (int i = 0; i < CAPACITY; i++)
        {
            q1.push(generic::to_string(i));
            if (q1.front() != generic::to_string(i)) { throw err; }
            q1.pop();
        }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_front5()
{
    string testid = "front.test.5";
    string desc = "push and pop until `last` is CAPACITY-2, push 3x, pop 2x check front";
    cout << "  " << testid << ": ";

    queue q1;
    while (q1.last != CAPACITY - 2)
    {
        q1.push("wombat");
        q1.pop();
    }
    q1.push("binturong");
    q1.push("okapi");
    q1.push("zebra");
    q1.pop();
    q1.pop();
    try {
        if (q1.front() != "zebra") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_front()
{
    cout << "\nTesting front" << " . . ." << endl;

    // Test 1: push 1x, check front
    test_front1();

    // Test 2: push 2x, check front
    test_front2();

    // Test 3: push 5x, check front
    test_front3();

    // Test 4: push and pop CAPACITY-1 different items, front always correct
    test_front4();

    // Test 5: push and pop until `last` is CAPACITY-2, push 3x, pop 2x, check front
    test_front5();
}

void test_copy_constructor1()
{
    string testid = "cpyconstr.test.1";
    string desc = "empty queue";
    cout << "  " << testid << ":";  

    queue q1;
    try {
        queue q2(q1);
        if (!q2.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_copy_constructor2()
{
    string testid = "cpyconstr.test.2";
    string desc = "1-item queue";  // NOLINT
    cout << "  " << testid << ":";  

    queue q1;
    q1.push("ziggy");

    try {
        queue q2(q1);
        if (q2.front() != "ziggy") { throw err; }
        if (q2.size() != 1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_copy_constructor3()
{
    string testid = "cpyconstr.test.3";
    string desc = "many pushes/pops to make size 3 before copying";  // NOLINT
    cout << "  " << testid << ":";  

    queue q1;
    string str;

    for (int i = 0; i < CAPACITY - 1; i++)
    {
        str = generic::to_string(i);
        q1.push(str);
    }

    for (int i = 0; i < CAPACITY - 1; i++)
    {
        str = generic::to_string(i);
        q1.pop();
    }
    assert(q1.empty());

    q1.push("eat");
    q1.push("more");
    q1.push("vegetables");

    try {
        queue q2(q1);   // activate the copy constructor
        if (q2.front() != "eat") { throw err; }
        q2.pop();
        if (q2.front() != "more") { throw err; }
        q2.pop();
        if (q2.front() != "vegetables") { throw err; }
        q2.pop();
        if (!q2.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_copy_constructor4()
{
    string testid = "cpyconstr.test.4";
    string desc = "full queue"; // NOLINT
    cout << "  " << testid << ":";  

    string str;
    queue q1;
    q1.push("a");
    q1.push("a");
    q1.pop();
    q1.pop();

    // make a full queue
    for (int i = 0; i < CAPACITY; i++)
    {
        str = generic::to_string(i);
        q1.push(str);
    }

    try {
        // activate copy constructor
        queue q2(q1);
        for (int i = 0; i < CAPACITY; i++)
        {
            if (q2.front() != generic::to_string(i)) { throw err; }
            q2.pop();
        }
        if (!q2.empty()) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_copy_constructor5()
{
    string testid = "cpyconstr.test.5";
    string desc = "test that copy and original are independent";  // NOLINT
    cout << "  " << testid << ":";  

    queue q1;
    q1.push("ants");
    q1.push("buy");
    q1.push("coffee");
    q1.pop();
    q1.push("now");

    try {
        queue q2(q1);
        if (q2.size() != q1.size()) { throw err; }
        q2.pop();
        if (q2.size() == q1.size()) { throw err; }
        if (q2.front() != "coffee") { throw err; }
        if (q1.front() != "buy") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_automatic_copy_constructor()
{
    cout << "\nTesting automatic copy constructor" << " . . ." << endl;

    // Test 1: copy an empty queue
    test_copy_constructor1();

    // Test 2: copy a queue of length 1, with first at index 0
    test_copy_constructor2();

    // Test 3: copy a 3-item queue with first at index CAPACITY - 1
    test_copy_constructor3();

    // Test 4: copy a full queue with first at index 2
    test_copy_constructor4();

    // Test 5
    test_copy_constructor5();
}

void test_exceptions1()
{
    string test = "  exceptions.test.1: when popping an empty queue";
    cout << test;

    try {
        queue q1;
        q1.pop();       // should throw domain_error
    } catch (domain_error&  e) {
        cout << " ... ok" << endl;
        return;
    }
    assert(false);      // shouldn't make it here;
}

void test_exceptions2()
{
    string test = "  exceptions.test.2: when fronting an empty queue";
    cout << test;

    try {
        queue q1;
        q1.front();     // should throw domain_error
    } catch (domain_error&  e) {
        cout << " ... ok" << endl;
        return;
    }
    assert(false);      // shouldn't make it here;
}

void test_exceptions3()
{
    string test = "  exceptions.test.3: when pushing a full queue";
    cout << test; 

    try {
        string str;
        queue q1;

        for (int i = 0; i < CAPACITY; i++)
        {
            str =  generic::to_string(i);
            q1.push(str);
        }
        q1.push("Hey, I'm full.");      // should throw domain_error
    } catch (domain_error&  e) {
        cout << " ... ok" << endl;
        return;
    }
    assert(false);      // shouldn't make it here;
}

void test_exceptions()
{
    cout << "\nTesting that exceptions are thrown when necessary . . ."
         << endl;

    // Test 1: pop an empty queue
    test_exceptions1();

    // Test 2: front() an empty queue
    test_exceptions2();

    // Test 3: push a full queue
    test_exceptions3();

    cout << ". . . exception throwing is OK!" << endl;
}

void test_equiv_inequiv1()
{
    string testid = "equneq.test.1";
    string desc = "different sized queues";
    cout << "  " << testid << ": ";

    // Setup: create differently sized queues
    string str;
    queue q1;
    for (int i = 0; i < 3; i++)
    {
        str =  generic::to_string(i);
        q1.push(str);
    }
    queue q2;
    for (int i = 0; i < 4; i++)
    {
        str =  generic::to_string(i);
        q1.push(str);
    }

    try {
        if (q1 == q2) { throw err; }
        if (q2 == q1) { throw err; }
        if (!(q1 != q2)) { throw err; }
        if (!(q2 != q1)) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv2()
{
    string testid = "equneq.test.2";
    string desc = "both queues empty";
    cout << "  " << testid << ": ";

    // Setup: create two empty queues
    queue q1;
    queue q2;

    try {
        if (!(q1 == q2)) { throw err; }
        if (!(q2 == q1)) { throw err; }
        if (q1 != q2) { throw err; }
        if (q2 != q1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv3()
{
    string testid = "equneq.test.3";
    string desc = "same size, same values, same order";
    cout << "  " << testid << ": ";

    // Setup: create identical queues, except have the first and last
    //  indexes of the two queues be different (e.g., same items in 
    //  same order, but in different locations in each queue)
    string str;
    queue q1;
    for (int i = 0; i < CAPACITY-3; i++)
    {
        q1.push("temp");
        q1.pop();
    }
    // q1 is empty, with last=27 and first=28

    queue q2;
    q2.push("temp");
    q2.pop();
    // q1 is empty, with last=1 and first=2

    // put the same items in q1 and q2
    for (int i = 0; i < 6; i++)
    {
        str =  generic::to_string(i);
        q1.push(str);
        q2.push(str);
    }

    try {
        if (!(q1 == q2)) { throw err; }
        if (!(q2 == q1)) { throw err; }
        if (q1 != q2) { throw err; }
        if (q2 != q1) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv4()
{
    string testid = "equneq.test.4";
    string desc = "same size, same values, diff order";
    cout << "  " << testid << ": ";

    // Setup: create two queues with the same items in different orders
    queue q1;
    q1.push("jack");
    q1.push("jill");
    queue q2;
    q2.push("jill");
    q2.push("jack");

    try {
        if (q1 == q2) { throw err; }
        if (q2 == q1) { throw err; }
        if (!(q1 != q2)) { throw err; }
        if (!(q2 != q1)) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv5()
{
    string testid = "equneq.test.5";
    string desc = "same size, diff first value";
    cout << "  " << testid << ": ";

    // Setup: create two queues that differ only in their first value
    queue q1;
    q1.push("ziggy");
    q1.push("cleo");
    q1.push("skye");
    queue q2;
    q2.push("spike");
    q2.push("cleo");
    q2.push("skye");

    try {
        if (q1 == q2) { throw err; }
        if (q2 == q1) { throw err; }
        if (!(q1 != q2)) { throw err; }
        if (!(q2 != q1)) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv6()
{
    string testid = "equneq.test.6";
    string desc = "same size, diff last value";
    cout << "  " << testid << ": ";

    // Setup: create two queues that differ only in their last value
    queue q1;
    q1.push("cleo");
    q1.push("skye");
    q1.push("ziggy");
    queue q2;
    q2.push("cleo");
    q2.push("skye");
    q2.push("spike");

    try {
        if (q1 == q2) { throw err; }
        if (q2 == q1) { throw err; }
        if (!(q1 != q2)) { throw err; }
        if (!(q2 != q1)) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_equiv_inequiv()
{
    cout << "\nTesting equivalence, inequivalence . . ." << endl;

    // Test 1: queues have different sizes
    test_equiv_inequiv1();

    // Test 2: both queues empty
    test_equiv_inequiv2();

    // Test 3: queues have same sizes, same values, same order 
    test_equiv_inequiv3();

    // Test 4: queues have same sizes, same values, different order
    test_equiv_inequiv4();

    // Test 5: queues have same sizes, first value differs
    test_equiv_inequiv5();

    // Test 6: queues have same sizes, last value differs
    test_equiv_inequiv6();
}

void test_reverse1()
{
    string testid = "reverse.test.1";
    string desc = "empty queue";
    cout << "  " << testid << ": ";

    queue q1;

    try {
        q1.reverse();
        if (!(q1.empty())) { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse2()
{
    string testid = "reverse.test.2";
    string desc = "queue of size 1";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("ziggy");

    try {
        q1.reverse();
        if (q1.size() != 1) { throw err; }
        if (q1.front() != "ziggy") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse3()
{
    string testid = "reverse.test.3";
    string desc = "queue of size 2";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("ziggy");
    q1.push("spike");
    q1.reverse();
    try {
        if (q1.size() != 2) { throw err; }
        if (q1.front() != "spike") { throw err; }
        q1.pop();
        if (q1.front() != "ziggy") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse4()
{
    string testid = "reverse.test.4";
    string desc = "queue of size 3";
    cout << "  " << testid << ": ";

    queue q1;
    q1.push("ziggy");
    q1.push("spike");
    q1.push("cleo");

    try {
        q1.reverse();
        if (q1.size() != 3) { throw err; }
        if (q1.front() != "cleo") { throw err; }
        q1.pop();
        if (q1.front() != "spike") { throw err; }
        q1.pop();
        if (q1.front() != "ziggy") { throw err; }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse5()
{
    string testid = "reverse.test.5";
    string desc = "full queue";
    cout << "  " << testid << ": ";

    string str;
    queue q1;
    for (int i = 0; i < CAPACITY; i++)
    {
        str =  generic::to_string(i);
        q1.push(str);
    }

    try {
        q1.reverse();
        if (q1.size() != CAPACITY) { throw err; }
        for (int i = CAPACITY - 1; i >= 0; i--)
        {
            str = generic::to_string(i);
            if (q1.front() != str) { throw err; }
            q1.pop();
        }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse6()
{
    string testid = "reverse.test.6";
    string desc = "with first=28 and last=5";
    cout << "  " << testid << ": ";

    string str;
    queue q1;
    for (int i = 0; i < CAPACITY-3; i++)
    {
        q1.push("temp");
        q1.pop();
    }
    // q1 is empty, with last=27 and first=28

    for (int i = 0; i < 8; i++)
    {
        str =  generic::to_string(i);
        q1.push(str);
    }

    try {
        q1.reverse();
        for (int i = 7; i >= 0; i--)
        {
            str = generic::to_string(i);
            if (q1.front() != str) { throw err; }
            q1.pop();
        }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse7()
{
    string testid = "reverse.test.7";
    string desc = "with first=25 and last=2";
    cout << "  " << testid << ": ";

    string str;
    queue q1;
    for (int i = 0; i < CAPACITY-6; i++)
    {
        q1.push("temp");
        q1.pop();
    }
    // q1 is empty, with last=24 and first=25

    for (int i = 0; i < 8; i++)
    {
        str =  generic::to_string(i);
        q1.push(str);
    }

    try {
        q1.reverse();
        for (int i = 7; i >= 0; i--)
        {
            str = generic::to_string(i);
            if (q1.front() != str) { throw err; }
            q1.pop();
        }
        itPassed(desc);
    }
    catch(string s){ itFailed(desc + " " + s); }
}

void test_reverse()
{
    cout << "\nTesting reverse . . ." << endl;

    // Test 1: reverse an empty queue
    test_reverse1();

    // Test 2: reverse a queue of size 1
    test_reverse2();

    // Test 3: reverse a queue of size 2
    test_reverse3();

    // Test 4: reverse a queue of size 3
    test_reverse4();

    // Test 5: reverse a full queue
    test_reverse5();

    // Test 6: reverse a queue with first=28 and last=5
    test_reverse6();

    // Test 7: reverse a queue with first=25 and last=2
    test_reverse7();
}

void printSummary()
{
    int num_tests = tests_passed + tests_failed;
    double passed = (double) tests_passed;
    double total = (double) num_tests;
    cout << "\nNumber of segmentation faults encountered during testing = "
         << segmentation_faults << endl;
    cout << "Number of infinite loops encountered during testing = "
         << infinite_loops << endl;
    cout << "Number of tests passed = " << tests_passed << " out of "
         << num_tests << endl;
    cout << "Number of tests failed = " << tests_failed << " out of "
         << num_tests << endl;
    cout << "Percent of tests passed = " << (100 * passed / total)
         << "%" << endl << endl;
}

int main()
{
    cout << "\nMASTERTEST Report (queue class)" << endl;
    test_default_constructor();
    test_push();
    test_pop();
    test_circular();
    test_empty();
    test_size();
    test_full();
    test_front();

    int basic_failed = tests_failed;
    if (basic_failed > 0)
    {
        string warning = generic::to_string(basic_failed);
        warning += " basic functionality test(s) failed; may need to patch";
        print_warning(warning);
    }

    test_equiv_inequiv();
    test_automatic_copy_constructor();
    test_reverse();
    
    printSummary();

    return 0;
}
